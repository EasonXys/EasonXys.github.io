<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JavaScript," />










<meta name="description" content="JS高级包括但不限于以下内容： 数据、变量及内存；函数；对象；原型及原型链、原型链的继承；执行上下文；作用域；闭包  ……">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript高级（尚硅谷）">
<meta property="og:url" content="http://easonxys.github.io/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/index.html">
<meta property="og:site_name" content="Amazing">
<meta property="og:description" content="JS高级包括但不限于以下内容： 数据、变量及内存；函数；对象；原型及原型链、原型链的继承；执行上下文；作用域；闭包  ……">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://easonxys.github.io/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png">
<meta property="og:image" content="http://easonxys.github.io/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/%E5%8E%9F%E5%9E%8B.jpg">
<meta property="og:image" content="http://easonxys.github.io/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B%E9%93%BE.png">
<meta property="og:image" content="http://easonxys.github.io/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%9B%BE%E8%A7%A3.jpg">
<meta property="og:image" content="http://easonxys.github.io/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89%5C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.jpg">
<meta property="og:image" content="http://easonxys.github.io/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E8%81%94%E7%B3%BB.jpg">
<meta property="og:image" content="http://easonxys.github.io/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89%5C%E9%97%AD%E5%8C%851.jpg">
<meta property="og:image" content="http://easonxys.github.io/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89%5C%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.jpg">
<meta property="og:image" content="http://easonxys.github.io/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/%E5%BE%AA%E7%8E%AF%E8%BD%AE%E8%AF%A2%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86%E5%9B%BE.png">
<meta property="og:image" content="http://easonxys.github.io/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89%5C%E5%BE%AA%E7%8E%AF%E8%BD%AE%E8%AF%A2%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86%E5%8A%A8%E5%9B%BE.gif">
<meta property="article:published_time" content="2020-05-24T14:53:52.000Z">
<meta property="article:modified_time" content="2020-07-29T06:44:44.734Z">
<meta property="article:author" content="Eason">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://easonxys.github.io/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://easonxys.github.io/2020/05/24/JavaScript高级（尚硅谷）/"/>





  <title>JavaScript高级（尚硅谷） | Amazing</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Amazing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">春有百花秋有月 夏有凉风冬有雪</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://easonxys.github.io/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/caticon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Amazing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript高级（尚硅谷）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-24T22:53:52+08:00">
                2020-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  14.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  54
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>JS高级包括但不限于以下内容：</p>
<p>数据、变量及内存；函数；对象；<u>原型及原型链</u>、原型链的继承；<u>执行上下文</u>；作用域；<u>闭包</u>  ……</p>
<a id="more"></a>

<h3 id="JS高级"><a href="#JS高级" class="headerlink" title="JS高级"></a>JS高级</h3><h4 id="一、数据、变量及内存"><a href="#一、数据、变量及内存" class="headerlink" title="一、数据、变量及内存"></a>一、数据、变量及内存</h4><p><strong>什么是数据？</strong></p>
<p>存储在内存中代表特定信息的东西，本质上是一串二进制数字。</p>
<p>数据的特点：可传递、可运算，一切皆数据</p>
<p>内存中所有操作的目标：数据，可进行  <u>算数运算、逻辑运算、赋值、运行函数</u></p>
<p><strong>什么是内存？</strong></p>
<p>内存条通电以后产生的可储存、执行数据代码的空间（临时的）</p>
<p>一块小内存存有两个数据：内部存储的数据、地址值数据<small>（基本类型变量也含有地址值，只是不用，但不是没有）</small>。</p>
<p><small>内存的产生和死亡：内存条（电路板）==》通电==》产生内存空间==》处理数据==》断电==》内存空间和数据都消失</small></p>
<p>内存分类：常量池（存放常量的内存区域）、栈（存放全局变量和局部变量的内存区域）、堆（存放对象的内存区域）。</p>
<ul>
<li><p><u>栈内存</u>：用来执行代码和存储基本类型的值</p>
<ul>
<li>全局：打开浏览器形成的全局作用域就是栈内存（关掉浏览器页面，全局栈内存才会销毁）</li>
<li>局部：手动执行函数形成的局部作用域是栈内存</li>
<li>块级：基于ES6的let/ const形成的块级作用域也是栈内存</li>
</ul>
<p>一般情况下，函数只要执行完成，形成的局部、块级栈内存就会被销毁释放掉；如果当前局部作用域的某些内容被它以外的变量或者其他事物所占用，那么当前栈内存就不能出栈释放（如：闭包）</p>
</li>
<li><p><u>堆内存</u>：用来存储引用数据类型的值</p>
<p>如果堆内存使用完后，我们想要手动释放它，则取消所有的占用：<u>赋值为null（null是空对象指针，也就是不指向任何的堆内存）</u>；如果有变量或者其他东西存储了堆内存中的地址，则当前堆内存被视为占用，不能销毁释放</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>栈内存</th>
<th>堆内存</th>
</tr>
</thead>
<tbody><tr>
<td>存储基本数据类型</td>
<td>存储引用数据类型</td>
</tr>
<tr>
<td>按值访问</td>
<td>按引用访问</td>
</tr>
<tr>
<td>存储的值大小固定</td>
<td>存储的值大小不定，可动态调整</td>
</tr>
<tr>
<td>由系统自动分配内存空间</td>
<td>由代码进行指定分配</td>
</tr>
<tr>
<td>空间小，运行效率高</td>
<td>空间大，运行效率相对较低</td>
</tr>
<tr>
<td>先进后出，后进先出</td>
<td>无序存储，可根据引用直接获取</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> | 栈内存空间 |		：<span class="number">1.</span> 供代码执行   <span class="number">2.</span> 存储基本数据类型值</span><br><span class="line"> |变量名|具体值|</span><br><span class="line"></span><br><span class="line"> 如果 <span class="keyword">var</span> a = xxx; ，那么a内存中到底保存什么？</span><br><span class="line">- xxx 是基本数据，栈空间中开辟了一块新的内存，存放变量的名称a和变量的值</span><br><span class="line">- xxx 是对象，在堆空间中开辟一块内存存放该对象，同时在栈中开辟一块内存空间存放变量名a和该对象在堆空间的地址值</span><br><span class="line">- xxx 是一个变量，保存的是xxx的内存内容（基本数据类型）    </span><br><span class="line"></span><br><span class="line"> |堆内存空间|		：用于存储引用类型的值</span><br><span class="line">|引用数据类型|</span><br></pre></td></tr></table></figure>

<img src="/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/内存空间.png" style="zoom: 80%;">

<p>当我们要访问堆内存中的引用数据类型时，实际上我们首先是从栈中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = <span class="number">0</span>; <span class="comment">// 栈</span></span><br><span class="line"><span class="keyword">var</span> a2 = <span class="string">'this is string'</span>; <span class="comment">// 栈</span></span><br><span class="line"><span class="keyword">var</span> a3 = <span class="literal">null</span>; <span class="comment">// 栈</span></span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">m</span>: <span class="number">20</span> &#125;; <span class="comment">// 变量b存在于栈中，&#123;m: 20&#125; 作为对象存在于堆内存中</span></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 变量c存在于栈中，[1, 2, 3] 作为对象存在于堆内存中</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">变量名</th>
<th align="center">具体值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>c</code></td>
<td align="center"><code>0x0012ff7d</code></td>
</tr>
<tr>
<td align="center"><code>b</code></td>
<td align="center"><code>0x0012ff7c</code></td>
</tr>
<tr>
<td align="center"><code>a3</code></td>
<td align="center"><code>null</code></td>
</tr>
<tr>
<td align="center"><code>a2</code></td>
<td align="center"><code>this is string</code></td>
</tr>
<tr>
<td align="center"><code>a1</code></td>
<td align="center"><code>0</code></td>
</tr>
</tbody></table>
<p><strong>什么是变量？</strong></p>
<p>变量就是在程序运行过程中它的值允许改变的量，由变量名和变量值组成。每个变量都对应一块小内存，变量名用来查找对应的内存，变量值是内存中保存的数据。</p>
<p><strong>内存、数据和变量三者之间的关系</strong></p>
<p>内存是用来存储数据的空间，变量是内存的标识，通过变量我们可以操作(读/写)内存中的数据。</p>
<p>JS中对变量的操作都是对栈中变量的内容（值或地址）进行操作，判断基本数据类型是否相等时，时对栈中变量的值进行比较，判断对象是否相等时比较的是栈中变量存放的地址值是否相等</p>
<p><strong>数据类型分类</strong></p>
<ul>
<li>基本（值）类型<ul>
<li>String：任意字符串</li>
<li>Number：任意数字</li>
<li>Boolean： true/ false</li>
<li>undefined： undefined</li>
<li>null： null</li>
</ul>
</li>
<li>对象（引用）类型<ul>
<li>Object：任意对象<ul>
<li>Function：一种特别的对象（可以执行调用）</li>
<li>Array：一种特别的对象（数值下标，内部数据是有序的）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>数据类型判断</strong></p>
<ul>
<li><p><code>typeof</code>：返回数据类型的字符串表达。</p>
<p>可以用于判断 undefined、数值、字符串、布尔值、function。它不能判断null、object和array。并且，当typeof一个未定义的变量时，不会抛出错误，而是返回‘undefined’。注意typeof返回的都是字符串类型</p>
<p><small>typeof null 的结果是”object”，这是浏览器的bug：所有的值在计算中都以二进制编码存储，浏览器中把前三位000的数据当做对象，而null的二进制前三位也是000，所以被识别为对象，但它不是对象，它是空对象指针，是基本类型值</small>。</p>
</li>
<li><p><code>实例A instanceof 类B</code>：用于判断对象的具体类型。</p>
<p>当前类的原型只要出现在实例对象的原型链上就返回true。但是它存在以下局限性</p>
<ul>
<li>要求检测的实例必须是对象数据类型的，基本数据类型的实例是无法基于它检测的</li>
<li>不管是数组对象还是正则对象，都是Object的实例，检测结果都是true，所以还是无法基于这个结果判断是否为普通对象</li>
</ul>
</li>
<li><p><code>===/ ==</code>：可以用于判断undefined、null</p>
</li>
<li><p><code>({}).toString.call(被检测的实例)</code>/<code>Object.prototype.toString.call(被检测的实例)</code>：返回值是一个字符串 “[Object 当前被检测实例所属的类]”。基于JS本身专门进行数据检测，是目前检测数据类型比较好的方法</p>
<p>每一种数据类型的构造函数的原型上都有toSting()方法，除了Object.prototype上的toString是返回当前实例所属类的信息（可用于检测数据类型）其余的都是转换为字符串。<code>Object.prototype.toString.call(被检测的实例对象)</code>就是将toString()方法执行，然后基于call让方法中的this指向检测的实例对象，这样就可以实现数据类型检测了。</p>
<p>它可以有效检测任何数据类型的值，但是它只能检测内置类，不能检测自定义类</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a, <span class="keyword">typeof</span> a, <span class="keyword">typeof</span> a===<span class="string">'undefined'</span>, a===<span class="literal">undefined</span>);</span><br><span class="line"><span class="comment">// undefined	'undefined' 	true				true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([])		<span class="comment">// [Object Array]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1=&#123;</span><br><span class="line">    b2:[<span class="number">1</span>,<span class="string">'abc'</span>,<span class="built_in">console</span>.log],</span><br><span class="line">    b3:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"helloworld"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Eason'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>, b1 <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">//true false</span></span><br><span class="line"><span class="built_in">console</span>.log(b1.b2 <span class="keyword">instanceof</span> <span class="built_in">Array</span>, b1.b2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true true</span></span><br><span class="line"><span class="built_in">console</span>.log(b1.b3 <span class="keyword">instanceof</span> <span class="built_in">Function</span>, b1.b3 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b1.b3 === <span class="string">'function'</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b1.b2[<span class="number">2</span>] === <span class="string">'function'</span>); <span class="comment">//true</span></span><br><span class="line">b1.b2[<span class="number">2</span>](<span class="number">4</span>);		<span class="comment">//4	</span></span><br><span class="line"><span class="built_in">console</span>.log(b1.b3()());		<span class="comment">//helloworld Eason</span></span><br></pre></td></tr></table></figure>

<p><strong>⭐数据类型面试问题</strong>：</p>
<ol>
<li><p>undefined与null的区别？</p>
<p>undefined代表定义但未赋值；null定义了并赋值为null</p>
</li>
<li><p>什么时候给变量赋值为null？</p>
<ul>
<li>初始赋值，表明将要赋值为对象</li>
<li>结束前，让变量指向的对象成为垃圾对象（被垃圾回收器回收）</li>
</ul>
</li>
<li><p>严格区别数据类型和变量类型</p>
<ul>
<li>数据的类型<ul>
<li>基本类型</li>
<li>对象类型</li>
</ul>
</li>
<li>变量的类型（变量内存值的类型）<ul>
<li>基本类型：保存的就是基本类型的数据</li>
<li>引用类型：保存的是地址值</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>其他相关问题</strong></p>
<ol>
<li><p>如果 <code>var a = xxx;</code>，a内存中到底保存什么？</p>
<ul>
<li>xxx 是基本数据，保存的就是这个数据</li>
<li>xxx 是对象，保存的是对象的地址值</li>
<li>xxx 是一个变量，保存的是xxx的内存内容（可能是基本类型，也可能是地址值）</li>
</ul>
</li>
<li><p>关于引用变量赋值的问题</p>
<ul>
<li><p>2个引用变量指向同一个对象，通过一个变量对象修改内部数据，另一个变量获取的是修改后的数据</p>
</li>
<li><p>2个引用变量指向同一个对象，让其中一个引用变量指向另一个对象，另一个引用变量依然指向前一个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">思考：为什么a.age没有改变</span><br><span class="line"><span class="keyword">var</span> a=&#123;<span class="attr">age</span>:<span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj=&#123;<span class="attr">age</span>:<span class="number">15</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">fun(a);</span><br><span class="line"><span class="built_in">console</span>.log(a.age);		<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line">在fun()调用时，a作为实参传入，即fun()中的obj拷贝了一份a的内容——对象&#123;<span class="attr">age</span>:<span class="number">12</span>&#125;的堆内存地址。而在fun()方法体中，让obj指向了&#123;<span class="attr">age</span>:<span class="number">15</span>&#125;对象，也就是说，此时Obj指向的是一个新的堆内存地址，之前指向&#123;<span class="attr">age</span>:<span class="number">12</span>&#125;的指针已经断开，因此这就不影响a的赋值，并且随着fun()的调用完成，obj占用的内存被释放。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在JS调用函数传递变量参数时，是值传递还是引用传递</p>
<ul>
<li>⭐理解1：都是值传递，如果实参是基本数据类型，则直接传递基本数据值；如果实参是对象，则传递的是地址值，但是这两种情况本质上都是储存在栈内存空间的值</li>
<li>理解2：可能是值传递（对应基本数据类型，传递的是基本值），也可能是引用传递（对应对象，传递的是地址值）</li>
</ul>
</li>
<li><p>JS引擎如何管理内存</p>
<ul>
<li><p>内存生命周期（全局变量的生命周期直至浏览器卸载页面才会结束，局部变量会在函数运行以后被删除）</p>
<ol>
<li>内存分配：当我们申明变量、函数、对象的时候，系统会自动为他 们分配内存</li>
<li>内存使用：即读写内存，也就是使用变量、函数等<small>（只有一种情况是写操作，即变量在等号的左侧，包括函数中形参传值，其他都是读操作）</small></li>
<li>内存回收：使用完毕，由垃圾回收机制自动回收不再使用的被释放掉的内存</li>
</ol>
</li>
<li><p>释放内存</p>
<ul>
<li>局部变量：函数执行完之后自动释放</li>
<li>对象：成为垃圾对象==》垃圾回收器回收</li>
</ul>
<p><small><strong>当一个对象没有任何的变量或属性对它进行引用 obj=null ，此时我们将永远无法操作该对象，这种对象就是一个垃圾对象。</strong></small></p>
</li>
</ul>
<p><small><strong>垃圾回收器</strong>：指的是某一段时间或者间隔后，成为垃圾对象后，才由垃圾回收器进行回收，需要垃圾回收器回收的都是全局变量</small></p>
<ul>
<li><small>查找引用方式（Webkit内核）：浏览器有自动回收垃圾的机制，定期间隔某段时间，把所有被占用的内存回收释放（此类垃圾回收机制较完善）</small></li>
<li><small>内存计数器方式（Trident内核）：当前内存被其它东西引用了，则给堆计数加1，取消占用后减1，当减到零之后，浏览器将其释放</small></li>
</ul>
</li>
</ol>
<hr>
<h4 id="二、对象"><a href="#二、对象" class="headerlink" title="二、对象"></a>二、对象</h4><p><strong>什么是对象？</strong></p>
<p>多个数据的封装体，是用来保存多个数据的容器</p>
<p><strong>为什么使用对象？</strong></p>
<p>统一管理多个数据</p>
<p><strong>对象是由什么组成的？</strong></p>
<p>属性：由属性名（字符串）和属性值（任意数据类型）组成。代表对象的状态数据</p>
<p>方法（一种特别的属性）：属性值为函数。代表对象的行为数据。</p>
<p><strong>如何访问对象内部数据？</strong></p>
<ul>
<li><p><code>对象.属性名</code></p>
</li>
<li><p><code>对象[&#39;属性名&#39;]</code></p>
<ul>
<li><p><strong>什么时候必须使用<code>[&#39;属性名&#39;]</code>的方式</strong>？</p>
<ol>
<li>属性名包含特殊字符：- 空格</li>
<li>属性名是一个变量，是不确定的</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h4><p><strong>什么是函数？</strong></p>
<p>实现定功能的n条语句的封装体，只有函数是可以执行的，其他类型的数据不能执行</p>
<p><strong>为什么使用函数？</strong></p>
<p>提高代码复用，便于阅读交流</p>
<p><strong>如果定义函数？</strong></p>
<p>函数声明</p>
<p>表达式</p>
<p><strong>如何调用（执行）函数？</strong></p>
<ul>
<li>test()：直接调用</li>
<li>obj.test()：通过对象，作为方法进行调用</li>
<li>new test()：new调用</li>
<li>test.call/ apply(obj)：临时让test()成为obj的方法进行调用，使用此方法可以让一个函数成为任意指定对象的方法进行调用</li>
</ul>
<p><strong>什么函数才是回调函数？</strong></p>
<ol>
<li>人为定义</li>
<li>不能人为调用</li>
<li>但最终执行（在某一个时刻或者某个条件下）</li>
</ol>
<p><strong>常见的回调函数</strong></p>
<ul>
<li>dom事件回调函数==》其中的this是发生事件的dom元素</li>
<li>定时器回调函数==》其中的this是window</li>
<li>ajax请求回调函数</li>
<li>生命周期回调函数</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>).onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//DOM事件回调函数</span></span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"hello"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;		<span class="comment">//定时器回调函数</span></span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"world"</span>);</span></span><br><span class="line">    &#125;,2000)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>IIFE（Immediately-Invoked Function Expression 立即执行函数表达式）</strong></p>
<p>IIFE的概念与匿名函数自调用等同</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">[形参<span class="number">1</span>,形参<span class="number">2</span>,...形参n]</span>)</span>&#123;</span><br><span class="line">    语句...</span><br><span class="line">&#125;)([实参<span class="number">1</span>,实参<span class="number">2</span>,...实参n]);</span><br></pre></td></tr></table></figure>

<p>作用：隐藏实现，不会污染外部（全局）命名空间，可以用它编写JS模块，执行之后自动释放内存</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"helloworld"</span>);</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a++);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.$=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;		<span class="comment">//向外暴露一个函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">test</span>: test&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 1.$是一个函数 2.$执行后返回的是一个对象</span></span><br><span class="line">  $().test();	<span class="comment">// helloworld   1</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="四、this关键字"><a href="#四、this关键字" class="headerlink" title="四、this关键字"></a>四、this关键字</h4><p><strong>this是什么？</strong></p>
<p>任何函数本质上都是通过某个对象来调用的，如果没有直接指定，那这个对象就是window。</p>
<p>所有函数内部都有一个变量this，它的值是调用函数的当前对象。</p>
<p><strong>如何确定this的值？</strong></p>
<ul>
<li>以函数的形式调用时，this永远都是window (使用严格模式时是undefined)</li>
<li>以方法的形式调用时，this就是调用方法的那个对象 </li>
<li>以构造函数的形式调用时（使用new关键字），this就是新创建的那个实例对象</li>
<li>使用call()和apply()调用时，this是指定的那个对象，即call()函数中的第一参数</li>
<li>在事件响应的函数中，this就是响应函数绑定的对象 </li>
<li>在定时器等回调函数中，this是window</li>
<li>箭头函数没有this,会向上级作用域层层查找,直至到全局的window中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">color</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.color=color;</span><br><span class="line">  <span class="keyword">this</span>.getColor=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.setColor=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.color=color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person(<span class="string">"red"</span>)		<span class="comment">//this 是window</span></span><br><span class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> Person(<span class="string">"yellow"</span>); <span class="comment">//this 是p</span></span><br><span class="line">p.getColor()	<span class="comment">//this 是p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj=&#123;&#125;;</span><br><span class="line">p.setColor.call(obj,<span class="string">"black"</span>); <span class="comment">//this 是obj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test=p.setColor;</span><br><span class="line">test();	<span class="comment">// this 是window</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fun2();		<span class="comment">//this 是window</span></span><br><span class="line">&#125;</span><br><span class="line">fun1();	<span class="comment">//this 是window</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="五、原型、原型链"><a href="#五、原型、原型链" class="headerlink" title="五、原型、原型链"></a>五、原型、原型链</h4><p><strong>函数的prototype属性</strong></p>
<p>每个函数都有一个prototype属性，它默认指向一个空的Object对象（即原型对象，此处的对象空指还没有添加我们设定的属性）。但Object构造函数的显示原型不满足这一点。</p>
<p>在构造函数的原型对象中有一个属性constructor（构造函数），它指向函数对象本身，因此我们也将类称为构造函数（实例对象的constructor指向它的构造函数或者称为类）。</p>
<p>每一个实例对象都有一个__proto__属性，属性值是当前实例所属类的prototype原型</p>
<img src="/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/原型.jpg" style="zoom: 67%;">

<p>⭐作用：可以通过prototype属性给原型对象添加属性（一般都是添加方法），从而使函数的所有实例对象自动拥有原型中的公有属性（公有方法）</p>
<p><small>在构造函数中，使用 <code>this.xxx=yyy</code>方式添加的是实例对象的私有属性，与 <code>实例.xxx=yyy</code>性质相同</small></p>
<p><strong>显式原型和隐式原型</strong></p>
<p>每个函数function都有一个prototype，即显式原型（属性），在定义构造函数时完成添加</p>
<p>每个实例对象都有一个__proto__，可称为隐式原型（属性），属性值是当前实例所属类的prototype原型对象，在实例化时完成添加</p>
<p><u>对象的隐式原型的值为其对应的构造函数的显式原型的值</u></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码举例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>)</span>&#123;		<span class="comment">//内部语句： this.prototype=&#123;&#125;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype,<span class="keyword">typeof</span> <span class="built_in">Date</span>.prototype);	<span class="comment">//Object&#123;...&#125;   object</span></span><br><span class="line"><span class="built_in">console</span>.log(Fun.prototype.constructor===Fun);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Fun.prototype.test=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"helloworld"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f=<span class="keyword">new</span> Fun();		<span class="comment">//内部语句 this.__proto__=Fun.prototype;</span></span><br><span class="line"><span class="comment">//函数的所有实例对象自动拥有原型中的属性（方法）</span></span><br><span class="line">f.test();		<span class="comment">// helloworld</span></span><br></pre></td></tr></table></figure>

<p>总结</p>
<ol>
<li>函数的prototype属性：在定义函数时自动添加，默认值时一个空Object对象</li>
<li>对象的__proto__属性：创建对象时自动添加，默认值为构造函数的prototype属性值</li>
<li>程序员能够直接操作显式原型，但不能直接操作隐式原型（ES6之前）</li>
</ol>
<p><strong>原型链</strong>（又叫隐式原型链）</p>
<p>原型链的本质是链表，原型链上的节点是各种原型对象。与普通链表使用next属性进行连接，原型链使用__proto__属性连接各种原型对象。</p>
<p>访问一个对象的属性时，先在自身属性中查找，找到则返回；如果没有，再沿__proto__这条链向上查找，找到返回；如果最终没有找到，则返回undefined。<u>（查找变量是沿着作用域链来查找的，如果找到则返回；找不到报错）</u></p>
<p>作用：查找对象的属性</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">举例：查找 a.b，</span><br><span class="line"><span class="code">	首先在作用域链中查找变量a，</span></span><br><span class="line"><span class="code">	如果不存在直接报错；</span></span><br><span class="line"><span class="code">	如果存在，则以a为对象查找其原型链上是否有b，</span></span><br><span class="line"><span class="code">		如果有则返回该属性；</span></span><br><span class="line"><span class="code">		如果没有返回undefined。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.test1=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test1()'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Fun.prototype.test2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test2()'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f=<span class="keyword">new</span> Fun();</span><br><span class="line"></span><br><span class="line">f.test1();		<span class="comment">//test1()</span></span><br><span class="line">f.test2();		<span class="comment">//test2()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f.test3);		<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(f.__proto__.__proto__.__proto__)	<span class="comment">//null   原型链尽头</span></span><br></pre></td></tr></table></figure>

<p><strong>原型链图解</strong></p>
<img src="/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/隐式原型链.png" style="zoom:67%;">

<img src="/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/原型链图解.jpg" style="zoom: 80%;">

<p>原型链举例</p>
<ul>
<li>普通对象的原型链：<code>obj-&gt;Object.prototype-&gt;null</code></li>
<li>普通数组的原型链：<code>arr-&gt;Array.prototype-&gt;Object.prototype-&gt;null</code></li>
<li>普通函数的原型链：<code>func-&gt;Function.prototype-&gt;Object.prototype-&gt;null</code></li>
</ul>
<p><strong>原型链总结</strong></p>
<ol>
<li><p>函数的显式原型指向的对象，默认是一个空的Object实例对象（但是Object构造函数不满足这一点)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Fun.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>)			<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>)		<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>)			<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>所有函数都是Function的实例（包括Function）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Fun.__proto__===<span class="built_in">Function</span>.prototype)			<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__===<span class="built_in">Function</span>.prototype) 	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object的原型对象是原型链的尽头</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__)		<span class="comment">//null</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p><strong>原型链属性问题</strong></p>
<ul>
<li>读取对象的属性值时：会自动到原型链中查找</li>
<li>设置对象的属性值时：不会查找原型链，如果当前对象中没有此属性，则直接在对象中添加该属性并设置其值</li>
<li>方法一般定义在原型中，属性一般通过构造函数定义（通过this关键字）在对象的本身上</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">Fun.prototype.a=<span class="string">'xxx'</span>;</span><br><span class="line"><span class="keyword">var</span> f1=<span class="keyword">new</span> Fun();</span><br><span class="line"><span class="keyword">var</span> f2=<span class="keyword">new</span> Fun();</span><br><span class="line"></span><br><span class="line">f2.a=<span class="string">'yyy'</span>;		<span class="comment">// 设置f2的私有属性</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.a,f2.a,f1,f2)	<span class="comment">//xxx 	yyy		object&#123; &#125;   object&#123;a:'yyy'&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person(<span class="string">'Eason'</span>,<span class="number">18</span>);</span><br><span class="line">p1.setName(<span class="string">'Eason Xu'</span>);</span><br><span class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> Person(<span class="string">'Bob'</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Person.prototype是一个对象，这个对象上定义了一个getName方法，这个方法你return的是this.name，重点来了，你这个方法是怎么执行的呢，p1.getName()执行的，所以getName方法中的this指的就是p1 new出来的实例对象，而p1这个对象上有name这个属性。*/</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.getName());					<span class="comment">//Eason Xu</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.__proto__===p2.__proto__)	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>instanceof 是如何判断的</strong></p>
<p>表达式<code>A instanceof B</code>，如果B函数的显示原型对象在A对象的原型链上，返回true，否则返回false，以此来判断A的具体对象类型</p>
<p><strong>new 一个对象背后做了些什么？</strong></p>
<ol>
<li>创建一个空的新对象</li>
<li>给对象设置__proto__，值为构造函数对象的prototype属性值</li>
<li>执行构造函数体（给对象添加属性/ 方法，并使构造函数中的this指向新对象）</li>
</ol>
<p><strong>⭐原型链面试题</strong></p>
<ol>
<li><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>{}
A.prototype.n=<span class="number">1</span>;
<span class="keyword">var</span> b=<span class="keyword">new</span> A();
A.prototype={
  n:<span class="number">2</span>,
  m:<span class="number">3</span>
}
<span class="keyword">var</span> c=<span class="keyword">new</span> A();
<span class="built_in">console</span>.log(b.n,b.m,c.n,c.m)    <span class="comment">// 1 undefined 2 3</span>
<span class="comment">/* new 的时候，b 的 prototype 会指向 A 的 prototype，而不是 A。</span>
<span class="comment">因此当改变 A 的 prototype，b 作为跟 A 并排的独立物件并不会受到影响*/</span>
&lt;!--￼<span class="number">16</span>--&gt;
</code></pre>
</li>
</ol>
<hr>
<h4 id="六、函数提升和变量提升"><a href="#六、函数提升和变量提升" class="headerlink" title="六、函数提升和变量提升"></a>六、函数提升和变量提升</h4><p><strong>预解析</strong>：JS引擎会把JS里面所有的var 和function提升到当前作用域的最前面，预解析分为变量声明提升和函数声明提升，预解析之后才会从上向下执行代码。</p>
<p><strong>变量声明提升</strong>：通过var定义（声明）的变量，在定义语句之前就可以访问到。若声明的时候没有赋值，那该变量的值是undefined。若声明时进行赋值，则声明提前，赋值语句保留在原位置。</p>
<p><strong>函数声明提升</strong>：使用function声明的函数，函数体整体被提升，在声明语句之前就可以进行调用，且它的值为函数定义。</p>
<p>预解析阶段，当变量名与函数名重合，优先保留函数，不管先后顺序。同一个标识符的情况下，变量声明与函数声明都会提升；函数声明会覆盖变量声明，但不会覆盖变量赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn();		<span class="comment">//undefined</span></span><br><span class="line"><span class="comment">/*原因，在函数作用域内也存在变量的声明提升，a的声明语句提前，但是赋值语句并不能得到提升，故函数调用输出时a的值为undefined*/</span></span><br><span class="line"></span><br><span class="line">fn2();		<span class="comment">//fun2()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn2()'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*原因，使用function直接声明的函数，在声明之前就可以调用*/</span></span><br><span class="line"></span><br><span class="line">fun3();		<span class="comment">// ReferenceError: fun3 is not defined</span></span><br><span class="line"><span class="keyword">var</span> fn3=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn3()'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*原因，使用var定义函数表达式，本质上还是变量提升 fun3的值为undefined，undefined无法被调用*/</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> foo;</span><br><span class="line">  	foo=<span class="number">10</span>;</span><br><span class="line">  	<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  	<span class="keyword">var</span> foo=<span class="string">"11"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar());	<span class="comment">//function</span></span><br><span class="line"><span class="comment">/*var foo = “11”，foo的声明部分提升了，也就是var foo; 而foo="11"并没有提升。foo函数先被提升，foo的类型是function，然后var foo;的声明因为没有值所以不能覆盖foo现有的值，另外其他的语句都没有提升，所以return以后都不会执行。*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="七、执行上下文（执行环境）"><a href="#七、执行上下文（执行环境）" class="headerlink" title="七、执行上下文（执行环境）"></a>七、执行上下文（执行环境）</h4><p>简而言之，<u>执行上下文是评估和执行 JavaScript 代码的环境的抽象概念</u>。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p>
<p>代码分类：全局代码、函数（局部）代码。<strong>代码中执行上下文的个数=n<small style="color:grey">（函数的调用次数）</small>+1</strong></p>
<ul>
<li><code>全局对象GO</code>：在Web浏览器中，全局执行环境被认为是window对象；</li>
<li><code>变量对象VO</code>：每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。在函数执行环境创建阶段生成该变量对象，在函数调用执行时，将其作为它的<code>活动对象AO</code></li>
</ul>
<p><strong>全局执行上下文</strong></p>
<ol>
<li><p>在执行全局代码前将window确定为全局执行上下文对象</p>
</li>
<li><p>对全局数据进行预处理</p>
<ul>
<li><p>var定义的全局变量==》undefined，添加为window的属性</p>
</li>
<li><p>function声明的全局函数==》具体赋值，添加为window的方法</p>
</li>
<li><p>this==》赋值（window）</p>
</li>
</ul>
</li>
<li><p>然后开始执行全局代码</p>
</li>
</ol>
<p><strong>函数执行上下文</strong></p>
<ol>
<li>在调用函数时，准备执行函数体之前，创建对应的函数执行环境的变量对象（虚拟的，存在栈中）</li>
<li>对局部数据进行预处理<ul>
<li>形参变量==》赋值（实参）==》添加为活动对象的属性</li>
<li>arguments==》赋值（实参列表），添加为活动对象的属性</li>
<li>var定义的局部变量==》undefined，添加为活动对象的属性</li>
<li>function声明的函数==》具体赋值，添加为活动对象的方法</li>
<li>this==》赋值（调用函数的对象）</li>
<li>未在该执行环境中定义的变量或函数==》沿着作用域链逐级向上找，如果找得到，则具体赋值，添加为活动对象的属性或方法后停止寻找；如果找不到，则报错。</li>
</ul>
</li>
<li>然后开始执行函数体代码</li>
</ol>
<p><strong>代码及图解举例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//1. 进入全局执行上下文							</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> bar=<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b=<span class="number">5</span>;</span><br><span class="line">  <span class="comment">//3. 进入fn执行上下文</span></span><br><span class="line">  fn(x+b);					</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn=<span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c=<span class="number">5</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a+c+y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 进入bar函数执行上下文</span></span><br><span class="line">bar(a);					<span class="comment">//30</span></span><br></pre></td></tr></table></figure>

<p><strong>执行上下文栈图解</strong></p>
<p>执行上下文栈：用于存储在代码执行期间创建的所有执行上下文</p>
<ol>
<li>在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象</li>
<li>在全局执行上下文(window)确定后, 将其添加到栈中(压栈)</li>
<li>在函数执行上下文创建后, 将其添加到栈中(压栈)</li>
<li>在当前函数执行完后,将栈顶的对象移除(出栈)</li>
<li>当所有的代码执行完后, 栈中只剩下window</li>
</ol>
<p><img src="/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89%5C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.jpg" alt></p>
<p><strong>⭐执行上下文面试题</strong></p>
<ol>
<li>以下代码的依次输出是多少？并且整个过程中产生了几个执行上下文？</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'global begin:'</span>+i)	<span class="comment">//global begin: undefined</span></span><br><span class="line"><span class="keyword">var</span> i=<span class="number">1</span>;</span><br><span class="line">foo(i)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo() begin:'</span>+i);</span><br><span class="line">  <span class="comment">//递归调用（递归调用也是一种特殊的嵌套调用）  </span></span><br><span class="line">  foo(i+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo() end:'</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'global end:'</span>+i)	<span class="comment">//global end: 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依次输出以下内容，整个过程产生了5个执行上下文</span></span><br><span class="line">global begin:<span class="literal">undefined</span> </span><br><span class="line">foo() begin:<span class="number">1</span> </span><br><span class="line">foo() begin:<span class="number">2</span> </span><br><span class="line">foo() begin:<span class="number">3</span> </span><br><span class="line">foo() end:<span class="number">3</span></span><br><span class="line">foo() end:<span class="number">2</span> </span><br><span class="line">foo() end:<span class="number">1</span> </span><br><span class="line">global end:<span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>测试题2</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预解析阶段，当变量名与函数名重合，优先保留函数，不管先后顺序</span></span><br><span class="line"><span class="comment">//同一个标识符的情况下，变量声明与函数声明都会提升；函数声明会覆盖变量声明，但不会覆盖变量赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a)		<span class="comment">//function</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>测试题3</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//js引擎在解析代码时，会统一先声明，再赋值，是把所有声明提升到顶端，而赋值依然保留在原来的位置。函数会优先被提升，并且是整个函数被提升，变量提升取最后一次赋值为最终值</span></span><br><span class="line"><span class="keyword">var</span> c=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line">c(<span class="number">2</span>);				<span class="comment">//TypeError: c is not a function</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*代码等同于</span></span><br><span class="line"><span class="comment">function c(c)&#123;</span></span><br><span class="line"><span class="comment">    console.log(c);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">var c;</span></span><br><span class="line"><span class="comment">c=1;</span></span><br><span class="line"><span class="comment">c(2);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>测试题4</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(b <span class="keyword">in</span> <span class="built_in">window</span>))&#123;</span><br><span class="line">    <span class="keyword">var</span> b=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b)		<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我的理解，if语句并不是函数，所以var b=1; 还是将b声明成了全局变量，只是没有执行赋值语句，此时b为undefined，同时 b in window 为真，赋值语句永远不会执行。故输出为undefined，这也是JS在ES5版本中没有块级作用域的体现，如果将var换成let将会报错 Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="八、作用域与作用域链"><a href="#八、作用域与作用域链" class="headerlink" title="八、作用域与作用域链"></a>八、作用域与作用域链</h4><p><strong>作用域</strong>：作用域是可访问变量（变量、对象、函数）的集合，就是一块“地盘”，即一个代码段所在的区域。它是静态的（相对于执行上下文只有在函数调用的时候才会动态创建），它在编写代码的时候就已经确定了。<strong>代码中作用域的个数=n<small style="color:grey">（定义函数的个数）</small>+1</strong></p>
<p><strong>作用域分类</strong> </p>
<ol>
<li>全局作用域</li>
<li>局部作用域</li>
<li>只有在ES6及以后版本才有块作用域</li>
</ol>
<p>变量在函数内声明，包括形参变量，变量有局部作用域（也叫 函数作用域），局部变量只能在函数内部被访问；</p>
<p>变量在函数外定义，即为全局变量，全局变量有全局作用域，网页中所有脚本和函数均可使用（<u>如果变量在函数内没有声明（没有使用var关键字），该变量为全局变量</u>）</p>
<p><strong>作用域作用</strong>：</p>
<ol>
<li>是保证执行上下文有权访问的所有变量和函数进行有序访问</li>
<li>函数作用域通过它的作用域链，可以实现变量的封装隔离防止污染。子层的函数可以访问父级以及全局的变量，但是反过来则不行，这样子层函数中的变量就与外界隔绝开来了。</li>
</ol>
<p><strong>作用域和执行上下文的区别</strong></p>
<ul>
<li><p><u>创建时间不同</u></p>
<p>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义的时候就已经确定了；而函数执行上下文是在调用函数时，函数体代码执行之前创建；</p>
<p>全局执行上下文是在全局作用域确定之后，JS代码执行之前创建</p>
</li>
<li><p><u>动/ 静态</u></p>
<p>作用域是静态的，只要函数定义好了就一直存在，且不再会再变化</p>
<p>执行上下文是动态的，调用函数时创建，函数调用结束时执行上下文就会自动释放</p>
</li>
</ul>
<p><strong>作用域和执行上下文的联系</strong></p>
<ul>
<li><p>执行上下文（对象）从属于所在的作用域</p>
<ul>
<li>全局执行上下文==》全局作用域</li>
<li>函数执行上下文==》对应的函数作用域</li>
</ul>
</li>
</ul>
<p><strong>作用域链</strong></p>
<p>当代码在一个执行上下文中执行，会创建变量对象的一个作用域链。<u>作用域链的作用是保证执行环境有权访问的所有变量和函数的有序访问</u></p>
<p>多个上下级关系的作用域形成的链，它的方向从下向上的（从内到外），查找变量是沿着作用域链来查找的，如果找到则返回，如果找不到则 <u><strong>报错</strong></u>。</p>
<img src="/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/作用域和执行上下文的联系.jpg" style="zoom: 33%;">

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b=<span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(c);		<span class="comment">//	3</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);		<span class="comment">//	2</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);		<span class="comment">//	1</span></span><br><span class="line">    <span class="built_in">console</span>.log(d);		<span class="comment">//	ReferenceError: d is not defined</span></span><br><span class="line">  &#125;</span><br><span class="line">  fn2();</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure>

<p><strong>⭐作用域面试题</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x=<span class="number">20</span>;</span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line">show(fn);		<span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fn);</span><br><span class="line">&#125;</span><br><span class="line">fn()		<span class="comment">//function fn()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">  fn2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fn2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn2();	 <span class="comment">//ReferenceError: fn2 is not defined</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = b = <span class="number">3</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a===<span class="string">"undefined"</span>,b);	<span class="comment">//true 3</span></span><br><span class="line"><span class="comment">/* var a = b =3 相当于</span></span><br><span class="line"><span class="comment">	b=3;      定义了全局变量b为3</span></span><br><span class="line"><span class="comment">	var a=b;  声明了局部变量a，并将b赋值给它	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="九、闭包"><a href="#九、闭包" class="headerlink" title="九、闭包"></a>九、闭包</h4><p><strong>如何产生闭包？</strong></p>
<p>当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量或函数时，就产生了闭包。</p>
<p><strong>闭包到底是什么？</strong></p>
<p>理解一：闭包是嵌套的内部函数</p>
<p>理解二：包含被引用变量（函数）的对象&lt;更加准确&gt;</p>
<p>注意：闭包存在于嵌套的内部函数中</p>
<p><strong>产生闭包的条件？</strong></p>
<ol>
<li>函数嵌套</li>
<li>内部函数引用了外部函数的数据（变量、函数）</li>
<li>外部函数被执行调用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> b=<span class="string">'abc'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    fn2();</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br><span class="line"><span class="comment">//使用Chrome在 var a=1; 处设置断点并进入（表示fn1函数已调用，且已经进入函数内部，此时函数、变量都已经得到声明），红框画出的就是闭包。b虽然存在于fn1函数作用域中，但是未在fn2中被引用，故b不存在于闭包中</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89%5C%E9%97%AD%E5%8C%851.jpg" alt></p>
<p><strong>常见闭包</strong></p>
<ul>
<li><p>将函数作为另一个函数的返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f=fn1();</span><br><span class="line"><span class="comment">//此时的f()实际上调用的是内部函数fn2()</span></span><br><span class="line">f();	<span class="comment">//3</span></span><br><span class="line">f();	<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">f=<span class="literal">null</span>;	<span class="comment">//闭包死亡</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将函数作为实参传递给另一个函数调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDelay</span>(<span class="params">msg,time</span>)</span>&#123;</span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">  &#125;,time)</span><br><span class="line">&#125;</span><br><span class="line">showDelay(<span class="string">'hello world'</span>,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>闭包的作用</strong></p>
<ul>
<li>使用函数内部的变量在函数执行完之后，仍然存活在内存中，从而延长了局部变量的声明周期</li>
<li>让函数外部可以操作（读写）到函数内部的数据（变量/ 函数）</li>
</ul>
<p><strong>闭包暴露给外面使用的两种方法</strong></p>
<ol>
<li><p><u>基于window.xxx=xxx暴露到全局</u></p>
<p>这种办法虽然可以实现，但是也会存在冲突，如果我们每一个版块都需要暴露更多的方法，同时都基于这种方法暴露到全局对象GO上，也可能导致方法之间的冲突</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">anonymous</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">queryURLParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想暴露到外面使用，可以暴露到全局上（赋值给全局对象GO =&gt;window）</span></span><br><span class="line">    <span class="built_in">window</span>.queryURLParams = queryURLParams;</span><br><span class="line">    <span class="built_in">window</span>.sum = sum;</span><br><span class="line">&#125;)();</span><br><span class="line">queryURLParams(); <span class="comment">//=&gt;window.queryURLParams()</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><u>基于单例设计模式</u>：基于对象数据类型，把描述当前事物的属性和方法统一放在一起分组管理，能够减少全局变量污染</p>
<p>每一个版块暴露到全局下只有一个变量而已，所有需要供别人调取的方法都在对象中（这样暴露一个或者多个都无所谓），避免了全局变量的污染，也同时实现了不同闭包之间方法的公用性</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> utils = (<span class="function"><span class="keyword">function</span> <span class="title">anonymous</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// queryURLParams：获取URL地址参数信息</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">queryURLParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sum：实现任意数求和</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把需要供外面访问的变量和方法，赋值给一个对象，最后返回（外层基于VAR utils定义变量来接收即可）</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        queryURLParams: queryURLParams,</span><br><span class="line">        sum: sum</span><br><span class="line">    &#125;; <span class="comment">//=&gt;return AAAFFF000;</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// console.log(utils); //=&gt;&#123;queryURLParams:函数,sum:函数&#125;</span></span><br><span class="line">utils.queryURLParams();</span><br><span class="line">utils.sum();</span><br></pre></td></tr></table></figure>

<p><strong>常见问题</strong></p>
<ul>
<li><p>函数执行后，函数内部声明的局部变量是否还存在</p>
<p><small>一般是不存在的，存在于闭包中的变量才可能存在</small></p>
</li>
<li><p>在函数外部能直接访问函数内部的局部变量吗</p>
<p><small>不能，但是通过闭包可以让外部操作它</small></p>
</li>
</ul>
<p><strong>闭包的生命周期</strong></p>
<ol>
<li><p>产生</p>
<p>在嵌套的内部函数定义执行完定义执行完时就产生了闭包。也就是说外部函数被调用，内部函数在函数声明提升时产生了闭包（并非在内部函数被调用时才产生）。<u>外部函数被调用了多少次，闭包就产生了多少次。</u></p>
</li>
<li><p>死亡</p>
<p>在嵌套的内部函数成为垃圾对象时，闭包死亡。</p>
</li>
</ol>
<p><strong>闭包的应用</strong></p>
<p>定义JS模块：</p>
<ul>
<li>具有特定功能的JS文件</li>
<li>将所有的数据和功能都封装在一个<u>函数内部</u>（私有的）</li>
<li>只向外暴露一个包含n个方法的对象和函数</li>
<li>模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--闭包的应用举例--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在html的主文件中--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"test.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//调用闭包中的方法</span></span></span><br><span class="line">    test.doSomething();</span><br><span class="line">    test.outPut();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在对应的test.js文件中</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="keyword">var</span> msg=<span class="string">"hello world"</span>;</span><br><span class="line">    <span class="comment">//操作数据的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">outPut</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向外暴露对象（给外部使用的方法）</span></span><br><span class="line">    <span class="built_in">window</span>.test=&#123;</span><br><span class="line">        doSomething:doSomething,</span><br><span class="line">        outPut:outPut</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>闭包的缺点</strong></p>
<ul>
<li>函数执行完之后函数内的局部变量没有释放，占用内存时间会变长</li>
<li>容易造成内存泄露</li>
</ul>
<p><strong>解决方法</strong></p>
<ul>
<li>能不用闭包就不用</li>
<li>及时释放</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f=fn1();</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">f=<span class="literal">null</span>;		<span class="comment">//让内部函数称为垃圾对象==》 回收闭包 释放内存空间</span></span><br></pre></td></tr></table></figure>



<p><small>内存溢出：一种程序运行出现的错误，<u>当程序运行需要的内存超过了剩余的内存时</u>，就抛出内存溢出的错误</small></p>
<p><small>内存泄漏：<u>占用的内存没有及时释放</u>，内存泄露积累多了也容易导致内存溢出。</small></p>
<p><small>其中常见的内存泄露有</small></p>
<p><small>（1）意外的全局变量</small></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无意间在局部函数中未声明变量就直接赋值，成为全局变量。在函数调用结束后本该被释放的它未能释放</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<p><small>（2）没有及时清理的计时器或回调函数</small></p>
<p><small>（3）闭包</small></p>
<p><strong>闭包的面试题</strong></p>
<ol>
<li><p>测试题一</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"The window"</span>;</span><br><span class="line"><span class="keyword">var</span> object=&#123;</span><br><span class="line">  name: <span class="string">"My object"</span>,</span><br><span class="line">  getNameFunc:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()());	<span class="comment">// The window</span></span><br><span class="line"><span class="comment">//此题不存在闭包。虽然呈现嵌套结构，但是内部函数并没有引用外部函数定义的数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试题二</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name2=<span class="string">"The window"</span>;</span><br><span class="line"><span class="keyword">var</span> object2=&#123;</span><br><span class="line">  name2: <span class="string">"My object"</span>,</span><br><span class="line">  getNameFunc:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that=<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.name2;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object2.getNameFunc()());	<span class="comment">//  My object</span></span><br><span class="line"><span class="comment">//此题存在闭包。呈现嵌套结构，同时内部函数引用外部函数定义的数据 that</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试题三，详解：<a href="https://www.cnblogs.com/xxcanghai/p/4991870.html" target="_blank" rel="noopener">https://www.cnblogs.com/xxcanghai/p/4991870.html</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于作用域链问题，首先在函数内部寻找fun，但是在创建对象内部的时候，并没有在函数作用域内创建fun（对象在堆中，变量在栈上，第二个fun并不在作用域链上），所以是访问不到第二个fun的，只能向上寻找，找到了第一个fun，所以第三个fun等同于第一个fun，而不与第二个fun相同  </span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n,o</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(o)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">//所有声明的匿名函数都是一个新函数。</span></span><br><span class="line">            <span class="comment">//因此第二个fun和第一个fun并不一样，只是名字相同</span></span><br><span class="line">            fun:<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;	</span><br><span class="line">                <span class="keyword">return</span> fun(m,n);x</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;x</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//第一次调用fun，n=0，o未定义，所以输出的o为undefined，并返回含有fun(m,0)方法的对象</span></span><br><span class="line">    <span class="keyword">var</span> a = fun(<span class="number">0</span>);  	<span class="comment">//undefined</span></span><br><span class="line">			<span class="comment">//调用fun(0).fun(x)，此时m为x，闭包了外层函数的n=0，返回fun(x,0)方法，输出0，并继续返回含有fun(m,x)的对象;</span></span><br><span class="line">			a.fun(<span class="number">1</span>);   <span class="comment">//0 </span></span><br><span class="line">			a.fun(<span class="number">2</span>);   <span class="comment">//0</span></span><br><span class="line">			a.fun(<span class="number">3</span>);   <span class="comment">//0</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//调用fun(0)，输出o为undefined，并返回含有fun(m,0)方法的对象</span></span><br><span class="line">	<span class="comment">//调用fun(0).fun(1)，此时m为1，闭包了外层函数的n=0，返回fun(1,0)方法，输出0，并继续返回含有fun(m,1)的对象;</span></span><br><span class="line">		<span class="comment">//调用fun(0).fun(1).fun(2),此时m为2，闭包了外层函数的n=1，返回fun(2,1)，输出1，并继续返回含有fun(m,2)的对象</span></span><br><span class="line">			<span class="comment">//调用fun(0).fun(1).fun(2).fun(3)，此时m为3，闭包了外部函数的n=2，返回fun(3,2)，输出2，并继续返回含有fun(m,3)的对象</span></span><br><span class="line">    <span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>);<span class="comment">//undefined,0,1,2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>);  <span class="comment">//undefined 0</span></span><br><span class="line">			c.fun(<span class="number">2</span>);   <span class="comment">//1</span></span><br><span class="line">			c.fun(<span class="number">3</span>);   <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h4 id="十、对象高级"><a href="#十、对象高级" class="headerlink" title="十、对象高级"></a>十、对象高级</h4><p><strong>对象的创建模式</strong></p>
<ul>
<li><p>方法一：Object构造函数模式</p>
<p>套路：先创建Object对象，再动态添加属性、方法</p>
<p>适用场景：起始时不确定对象内部数据</p>
<p>问题：语句太多</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p =<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">p.name=<span class="string">'Eason'</span>;</span><br><span class="line">p.age=<span class="number">18</span>;</span><br><span class="line">p.setName=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line">p.setName(<span class="string">'EasonXu'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p);			<span class="comment">//Object &#123; name: "EasonXu", age: 18, setName: setName(name) &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：对象字面量模式（也就是 单例设计模式）</p>
<p>套路：使用{}创建对象，同时指定属性、方法</p>
<p>适用场景：起始时对象内部数据是确定的</p>
<p>问题：如果创建多个对象，有重复代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p =&#123;</span><br><span class="line">  name:<span class="string">'Eason'</span>,</span><br><span class="line">  age:<span class="number">18</span>,</span><br><span class="line">  setAge:<span class="function"><span class="keyword">function</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">p.setAge(<span class="number">24</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.age);		<span class="comment">//24</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法三：工厂设计模式</p>
<p>套路：通过工厂函数（返回一个对象的函数都称为工厂函数）动态创建对象并返回</p>
<p>适用场景：需要创建多个对象</p>
<p>问题：<u><em>对象没有一个具体的类型</em></u>，都是Object类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age</span>)</span>&#123;	<span class="comment">//工厂函数</span></span><br><span class="line">  <span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:name,</span><br><span class="line">    age:age,</span><br><span class="line">    setName:<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1=createPerson(<span class="string">'Eason'</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> p2=createPerson(<span class="string">'Jackie'</span>,<span class="number">22</span>);</span><br><span class="line">p1.setName(<span class="string">'EasonXu'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.name);		<span class="comment">//EasonXu</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.name);		<span class="comment">//Jackie</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法四：自定义构造函数模式</p>
<p>套路：自定义构造函数，通过new创建对象</p>
<p>适用场景：需要创建多个类型确定的对象</p>
<p>问题：每个对象都有相同的数据，浪费内存</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">this</span>.age=age;</span><br><span class="line">  <span class="keyword">this</span>.setName=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;	<span class="comment">//实例化后，该方法会存放在每一个实例对象中，会浪费内存</span></span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person(<span class="string">'Eason'</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> Person(<span class="string">'Jackie'</span>,<span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.name, p1 <span class="keyword">instanceof</span> Person)		<span class="comment">//Eason true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name,price,life</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">this</span>.price=price;</span><br><span class="line">  <span class="keyword">this</span>.life=life;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d1=<span class="keyword">new</span> Dog(<span class="string">'Bobe'</span>,<span class="number">1200</span>,<span class="number">13</span>)</span><br><span class="line"><span class="built_in">console</span>.log(d1.name,d1 <span class="keyword">instanceof</span> Person);			<span class="comment">//Bobe false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>⭐方法五：构造函数+原型的组合模式</p>
<p>套路：自定义构造函数，属性在函数中初始化，方法添加到原型上</p>
<p>适用场景：需要创建多个类型确定的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person(<span class="string">'Eason'</span>,<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1);			<span class="comment">//Object &#123; name: "Eason", age: 18 &#125;</span></span><br><span class="line">p1.setName(<span class="string">'EasonXu'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.name);		<span class="comment">//EasonXu</span></span><br><span class="line"><span class="comment">//p1对象并不存在setName()函数，却能调用，就是因为该函数存在p1对象的原型中</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="十一、原型链的继承"><a href="#十一、原型链的继承" class="headerlink" title="十一、原型链的继承"></a>十一、原型链的继承</h4><p><strong>方法一：原型链继承</strong></p>
<p>套路：</p>
<ol>
<li>定义父类型构造函数</li>
<li>给父类型的原型添加方法</li>
<li>定义子类型构造函数</li>
<li><u>创建父类型的对象赋值给子类型的原型</u><code>Son.prototype=new Parent();</code>&lt;这步是关键&gt;</li>
<li>将子类型原型的构造属性constructor设置为子类型</li>
<li>给子类型原型添加方法</li>
<li>创建子类型的对象，此时子类型的实例对象可以调用父类型的方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类型构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.parentInfo=<span class="string">"I am father"</span>;</span><br><span class="line">  <span class="keyword">this</span>.showParentInfo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.parentInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类型构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sonInfo=<span class="string">"I am son"</span>;</span><br><span class="line">  <span class="keyword">this</span>.showSonInfo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.sonInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类型的原型为父类型的一个实例对象 </span></span><br><span class="line">Son.prototype=<span class="keyword">new</span> Parent();</span><br><span class="line"><span class="comment">//子类型的原型的constructor属性指向子类型</span></span><br><span class="line">Son.prototype.constructor=Son;</span><br><span class="line"><span class="keyword">var</span> s=<span class="keyword">new</span> Son();</span><br><span class="line">s.showParentInfo();</span><br></pre></td></tr></table></figure>

<p><strong>方法二：借用构造函数继承（伪继承）</strong></p>
<p>套路：</p>
<ol>
<li>定义父类型构造函数</li>
<li>定义子类型构造函数</li>
<li><u>在子类型构造函数通过call()或apply()函数的调用父类型构造函数</u>&lt;这步是关键&gt;</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">this</span>.age=age;</span><br><span class="line">  <span class="keyword">this</span>.setName=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,schoolFee,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.schoolFee=schoolFee;</span><br><span class="line">  <span class="comment">//相当于this借用了一下Person构造函数，</span></span><br><span class="line">  <span class="comment">//当Student实例化时，这里的this就是新的实例对象  </span></span><br><span class="line">  Person.call(<span class="keyword">this</span>,name,age); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s=<span class="keyword">new</span> Student(<span class="string">'Eason'</span>,<span class="number">10000</span>,<span class="number">18</span>);</span><br><span class="line">s.setName(<span class="string">'EasonXu'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.name);</span><br></pre></td></tr></table></figure>

<p><strong>⭐方法三：组合继承</strong>（原型链+借用构造函数的组合继承）</p>
<ol>
<li>利用原型链实现对父类型对象的方法的继承</li>
<li>利用call()或apply()函数借用父类型构造函数初始化相同属性</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,schoolFee,age</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>,name,age);			<span class="comment">//为了得到属性声明</span></span><br><span class="line">    <span class="keyword">this</span>.schoolFee=schoolFee;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="comment">//为了能继承父类型的方法</span></span><br><span class="line">Student.prototype=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//修正constructor属性</span></span><br><span class="line">Student.prototype.constructor=Student;</span><br><span class="line">Student.prototype.getInfo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name+<span class="string">" "</span>+<span class="keyword">this</span>.schoolFee+<span class="string">" "</span>+<span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s=<span class="keyword">new</span> Student(<span class="string">'Eason'</span>,<span class="number">10000</span>,<span class="number">18</span>);</span><br><span class="line">s.setName(<span class="string">'EasonXu'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.getInfo());		<span class="comment">//EasonXu 10000 18</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="十二、进程与线程"><a href="#十二、进程与线程" class="headerlink" title="十二、进程与线程"></a>十二、进程与线程</h4><p><strong>进程</strong>：程序的一次执行, 它占有一片独有的内存空间。负责为程序的运行提供必备的环境,相当于工厂中的车间。</p>
<p><strong>线程</strong>：是进程内的一个独立执行单元；是程序执行的一个完整流程； 是CPU的最小的调度单元。相当于工厂中的工人</p>
<p><strong>相关知识</strong></p>
<ul>
<li>应用程序必须运行在某个进程的某个线程上</li>
<li>一个进程中至少有一个运行的线程: 主线程,  进程启动后自动创建</li>
<li>一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的</li>
<li>一个进程内的数据可以供其中的多个线程直接共享</li>
<li>多个进程之间的数据是不能直接共享的</li>
<li>线程池(thread pool): 保存多个线程对象的容器, 实现线程对象的反复利用</li>
</ul>
<p><img src="/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89%5C%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.jpg" alt></p>
<p><strong>何为多进程与多线程</strong>?<br>    多进程运行: 一应用程序可以同时启动多个实例运行<br>    多线程: 在一个进程内, 同时有多个线程运行</p>
<p><strong>比较单线程与多线程?</strong></p>
<ul>
<li><p><u>多线程</u></p>
<ul>
<li><p>优点</p>
<p>能有效提升CPU的利用率</p>
</li>
<li><p>缺点<br>创建多线程开销<br>线程间切换开销<br>死锁与状态同步问题</p>
</li>
</ul>
</li>
<li><p><u>单线程</u></p>
<ul>
<li><p>优点<br>顺序编程简单易懂</p>
</li>
<li><p>缺点<br>效率低</p>
</li>
</ul>
</li>
</ul>
<p>*<em>JS是单线程运行的，回调函数也是在主线程 *</em>（适用HTML5中的Web Workers可以多线程运行）</p>
<p><strong>JS代码分类</strong></p>
<ul>
<li>初始化执行代码（同步代码）：包含绑定DOM事件监听，设置定时器，发送ajax请求的代码等</li>
<li>回调执行代码（异步代码）：处理回调逻辑</li>
</ul>
<p><small>“<u>同步模式</u>“ 就是后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；</small></p>
<p><small>“<u>异步模式</u>” 在所有初始化代码被执行之后才可能得到执行，程序的执行顺序与任务的排列顺序是不一致的、异步的</small></p>
<p><strong>JS引擎执行代码的基本流程</strong></p>
<ol>
<li>先执行初始化代码，其中包含一些特殊的代码，如：<ul>
<li>设置定时器</li>
<li>绑定事件监听</li>
<li>发送ajax请求</li>
</ul>
</li>
<li>之后在某个时刻才会执行回调代码</li>
</ol>
<p><strong>为什么JS要使用单线程模式而不是多线程模式？</strong></p>
<p>作为浏览器脚本语言，Javascript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程的，否则会带来很多很复杂的同步问题。<small>(比如，一个更新操作，一个删除操作，如果是多线程运行，那么会存在线程间切换开销，可能会在更新到一半的时候发生删除操作，从而报错)</small></p>
<p>  <strong>JS事件循环模型</strong></p>
<p>模型的2个重要组成部分：</p>
<ul>
<li><u>事件管理模块</u>（WebAPIs，包括 定时器/ DOM事件/ Ajax 管理模块）</li>
<li><u>回调队列</u>（即回调函数的一个待处理的缓存容器，包含任务队列 task queue、消息队列 message queue、事件队列 event queue）</li>
</ul>
<p>模型的运转流程：</p>
<ol>
<li><p>执行初始化代码（同步代码），将异步的事件回调函数交给对应的模块管理</p>
</li>
<li><p>当事件发生时（如完成计时器延时），管理模块会将回调函数及其数据添加到回调队列中</p>
</li>
<li><p>只有当初始化代码（同步代码）执行完之后（可能要一段时间），才会遍历读取回调队列中的回调函数（异步代码）执行</p>
<p><small><strong>&lt;事件驱动模型原理图&gt;</strong></small></p>
</li>
</ol>
<p>​                                    <img text-align="center" src="/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/循环轮询模型原理图.png"></p>
<p>简单概念：</p>
<ul>
<li>事件轮询 event loop：在任务队列中循环取出回调函数放入执行栈中处理（一个接一个，先进先出）</li>
<li>回调队列</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"First"</span>);</span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Second"</span>), <span class="number">500</span>);</span><br><span class="line"><span class="keyword">const</span> baz = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Third"</span>);</span><br><span class="line"></span><br><span class="line">bar();		</span><br><span class="line">foo();</span><br><span class="line">baz();</span><br><span class="line"></span><br><span class="line"><span class="comment">//依次输出：	First  Third  Second</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89%5C%E5%BE%AA%E7%8E%AF%E8%BD%AE%E8%AF%A2%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86%E5%8A%A8%E5%9B%BE.gif" alt></p>
<p><strong>浏览器都是多线程的，但是JS渲染或者页面渲染是单线程的，浏览器既有单进程的</strong>（Firefox 老版IE）<strong>也有多进程的</strong>（Chrome 新版IE）</p>
<p>浏览器常用线程</p>
<ul>
<li><p>GUI渲染线程：渲染和绘制页面</p>
<p>其中GUI 在渲染页面时，当遇到其他请求时存在两种处理方法</p>
<ul>
<li><p>同步操作（import引入外部样式表的操作方法）：</p>
<p>让GUI线程自己去取，在CSS文件没有从服务器加载回来之前，下面的代码不会继续渲染</p>
</li>
<li><p>异步操作（&lt;link&gt;引入外部样式表的操作方法）</p>
<p>再行开辟一个线程，专门去服务器加载CSS文件。此时不用管CSS是否加载回来，GUI线程可以继续向下渲染</p>
</li>
</ul>
<p>因此使用&lt;link&gt;可以提高页面渲染速度</p>
</li>
<li><p>JS引擎线程：运行和渲染JS代码</p>
</li>
<li><p>事件管控和触发线程</p>
</li>
<li><p>定时器管控和触发线程</p>
</li>
<li><p>异步HTTP请求线程</p>
</li>
<li><p>……</p>
</li>
</ul>
<p><strong>浏览器内核</strong></p>
<p>浏览器内核由 渲染引擎 和 JS引擎 两部分组成，是支撑浏览器运行的最核心的程序</p>
<p>内核介绍：</p>
<ul>
<li>Trident（IE）</li>
<li>Gecko（FireFox）</li>
<li>Webkit（Safari/Chrome）</li>
<li>Blink（Chrome/Opera）</li>
</ul>
<p>国内大多数浏览器采用双核驱动（Trident&amp;Webkit 或者 Trident&amp;Blink）</p>
<p><strong>浏览器内核由很多模块组成</strong></p>
<ul>
<li><p>主线程</p>
<ul>
<li>js引擎模块 : 负责js程序的编译与运行</li>
<li>html,css文档解析模块 : 负责页面文本的解析</li>
<li>DOM/CSS模块 : 负责dom/css在内存中的相关处理 </li>
<li>布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)<br>……</li>
</ul>
</li>
<li><p>分线程</p>
<ul>
<li><p>定时器模块 : 负责定时器的管理</p>
</li>
<li><p>DOM事件响应模块 : 负责事件的管理</p>
</li>
<li><p>网络请求模块 : 负责ajax请求</p>
<p>​    ……</p>
</li>
</ul>
</li>
</ul>
<p><strong>H5 Web Workers(多线程)</strong></p>
<p>Web Workers 是 HTML5 提供的一个javascript多线程解决方案，可以将一些大计算量的代码交由web Worker运行而不冻结用户界面，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。<br><strong>使用</strong></p>
<ol>
<li>创建在分线程执行的js文件</li>
<li>在主线程中的js中发消息并设置回调</li>
</ol>
<h4 id="十三、面向对象编程（OOP）"><a href="#十三、面向对象编程（OOP）" class="headerlink" title="十三、面向对象编程（OOP）"></a>十三、面向对象编程（OOP）</h4><p>面向对象程序设计中的三大概念：</p>
<ul>
<li><p>对象：泛指，JS中我们操作和研究的事物都是对象</p>
</li>
<li><p>类：把抽象的对象，按照功能特点，进行的详细划分</p>
<ul>
<li>内置类</li>
<li>自定义类（类名的第一个字母一般都是大写的）</li>
</ul>
</li>
<li><p>实例：每一个类别中具体的事物</p>
</li>
</ul>
<p>其中对<strong>内置类</strong>的进行细分（内置类 ：根据JS中事物的特征，默认划分号的类别）</p>
<ul>
<li><u>数据类型中的内置类</u><ul>
<li>Number 类</li>
<li>String 类</li>
<li>Boolean 类</li>
<li>Null/ Undefined 类</li>
<li>Symbol 类</li>
<li>Object 对象数据类型类：所有对象类型都是这个类的一个实例<ul>
<li>Object 类：{}普通对象就是它的实例</li>
<li>Array 数组类：每一个数组是Array类的实例，也是Object 类的实例</li>
<li>RegExp 正则类</li>
<li>Date 日期类</li>
<li>……</li>
</ul>
</li>
<li>Function 类：所有函数都是这个类的实例</li>
</ul>
</li>
<li><u>DOM元素或者DOM元素集合的内置类</u><ul>
<li>Node 类<ul>
<li>文档节点类（Document）：整个HTML文档 <ul>
<li>HTMLDocument：每一个Document都是该类的实例</li>
</ul>
</li>
<li>元素节点类（Element）：HTML文档中的HTML标签<ul>
<li>HTMLDivElement 类：每一个div元素都是该类的实例</li>
<li>HTMLAnchorElement 类：每一个a元素都是该类的实例</li>
<li>……</li>
</ul>
</li>
<li>属性节点类（Attribute）：元素的属性</li>
<li>文本节点类（Text）：HTML标签中的文本内容</li>
</ul>
</li>
<li>HTMLCollection 元素集合类：基于 getElementByTagName 等方法获取到的元素集合都是它的一个实例</li>
<li>NodeList节点集合类</li>
<li>……</li>
</ul>
</li>
</ul>
<p><strong>自定义类与构造函数</strong></p>
<p>想创建自定义类和创建类的实例，只需要使用 <code>new 构造函数名()</code>执行，这样的函数称为类，返回结果为类的实例。在构造函数中（不建议手动写return，防止实例被覆盖）</p>
<p>​    如果没有 return，默认返回当前类的实例对象；</p>
<p>​    如果有 return，并且返回基本类型值，最后返回结果还是类的实例</p>
<p>​    如果有 return，而返回的是一个引用数据类型，则会把默认返回的实例给覆盖掉</p>
<p><strong>检测实例的方法</strong></p>
<ul>
<li><p><code>A instanceof B</code></p>
<p>检测当前实例A是否属于这个类B，B的原型只要出现在实例A的原型链上就返回 true；</p>
<p>不适用于基本数据类型检测，要求检测的实例必须是对象数据类型的</p>
</li>
<li><p><code>对象.hasOwnProperty(属性)</code></p>
<p>检测当前的某一属性是否为实例（或者对象）的<u>私有属性</u>，返回值为布尔值</p>
</li>
<li><p><code>属性 in 对象</code></p>
<p>检测当前属性是否为对象的属性，不管是公有还是私有的属性</p>
</li>
</ul>
<h4 id="十四、柯理化函数编程思想"><a href="#十四、柯理化函数编程思想" class="headerlink" title="十四、柯理化函数编程思想"></a>十四、柯理化函数编程思想</h4><p>柯理化（Currying）：<u>利用模块化思想处理多参函数，通过组合函数减少每个函数的入参数量,把多参函数转换为一系列单参函数并进行调用的技术，从而提高代码的可阅读性及可维护性</u>。</p>
<p>柯理化表现：将一个需要传入多个变量的函数变为多个嵌套函数，并且内层的函数会调用上层函数的变量，即使用闭包返回一个函数（当函数被调用时，返回的函数还需要设置一些传入的参数）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 普通函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>));		<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 柯理化函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curriedAdd</span>(<span class="params">num1</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(curriedAdd(<span class="number">3</span>)(<span class="number">4</span>))	<span class="comment">//7</span></span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出，柯理化很像现在流行的组件化开发模式，将多个函数模块组合起来，得到一个新的函数。</p>
<p>柯理化函数的核心是<u>闭包</u>，因为闭包，所以内层函数才能够保留父作用域中的变量。</p>
<p><strong>通用的柯理化函数</strong></p>
<p><u>版本一</u></p>
<p>可以看到，currying 函数将除了第一个fun函数变量，将其他参数变量都赋值在args变量中，然后将其合并在返回函数的变量参数中，给返回函数使用</p>
<p>但是这种方式创建的柯理化函数只能调用一次</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fun</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//arguments是类数组，因此利用call的方法利用数组的slice获取currying函数的其他传入值(非第一参数，此处是20 30 100)并存入args中</span></span><br><span class="line">  <span class="keyword">var</span> args=<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//将currying的其他传入值(此处是20 30)和curriedArr的传入值（此处是10）相并为新数组</span></span><br><span class="line">    <span class="comment">//并使用apply的方法将数组结果传给该函数（因为没有考虑到执行环境，所以apply的第一参数为null）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> _args=args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//由于_args在之前运算使用了外部函数的args，现在又将其暴露出去，_args和args都形成了闭包</span></span><br><span class="line">    <span class="comment">//闭包：将一些信息提前存储到不销毁的内存中去</span></span><br><span class="line">    <span class="keyword">return</span> fun.apply(<span class="literal">null</span>,_args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ES6语法的累加函数（参数可以任意添加多个）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...vals</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> vals.reduce(<span class="function">(<span class="params">pre,val</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre+val;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终目的是为了调用currying函数中返回的匿名函数</span></span><br><span class="line"><span class="keyword">var</span> curriedAdd=currying(add,<span class="number">20</span>,<span class="number">30</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//当执行currying函数中返回的匿名函数，之前存储的数据也会被用到本次执行cao'zu</span></span><br><span class="line"><span class="built_in">console</span>.log(curriedAdd(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p><u>版本二</u></p>
<p>实现柯里化工厂函数，可以多次调用，最后统一求值。</p>
<p>这种方式，把每次函数调用的参数都存储起来，如果已无参形式调用，说明记录结束，需要做最终计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fun</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args=<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//当括号中无实参，即括号表示函数调用时才执行</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length===<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> fun.apply(<span class="keyword">this</span>,args)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">Array</span>.prototype.push.apply(args,<span class="built_in">arguments</span>);</span><br><span class="line">      <span class="comment">//arguments中存在一个属性callee，这个属性对应一个函数对象，就是当前正在执行的函数对象。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...vals</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> vals.reduce(<span class="function">(<span class="params">pre,val</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre+val;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curriedAdd = currying(add, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">curriedAdd(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">curriedAdd(<span class="number">6</span>, <span class="number">7</span>)(<span class="number">8</span>)(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(curriedAdd(<span class="number">10</span>)())		<span class="comment">//55</span></span><br></pre></td></tr></table></figure>
















      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/12/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/" rel="next" title="JavaScript基础（尚硅谷）">
                <i class="fa fa-chevron-left"></i> JavaScript基础（尚硅谷）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/02/ES6%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/" rel="prev" title="JavaScript高级（尚硅谷）">
                JavaScript高级（尚硅谷） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/caticon.jpg"
                alt="Eason" />
            
              <p class="site-author-name" itemprop="name">Eason</p>
              <p class="site-description motion-element" itemprop="description">学习备忘录</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#JS高级"><span class="nav-number">1.</span> <span class="nav-text">JS高级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、数据、变量及内存"><span class="nav-number">1.1.</span> <span class="nav-text">一、数据、变量及内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、对象"><span class="nav-number">1.2.</span> <span class="nav-text">二、对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、函数"><span class="nav-number">1.3.</span> <span class="nav-text">三、函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、this关键字"><span class="nav-number">1.4.</span> <span class="nav-text">四、this关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、原型、原型链"><span class="nav-number">1.5.</span> <span class="nav-text">五、原型、原型链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#六、函数提升和变量提升"><span class="nav-number">1.6.</span> <span class="nav-text">六、函数提升和变量提升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#七、执行上下文（执行环境）"><span class="nav-number">1.7.</span> <span class="nav-text">七、执行上下文（执行环境）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#八、作用域与作用域链"><span class="nav-number">1.8.</span> <span class="nav-text">八、作用域与作用域链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#九、闭包"><span class="nav-number">1.9.</span> <span class="nav-text">九、闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十、对象高级"><span class="nav-number">1.10.</span> <span class="nav-text">十、对象高级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十一、原型链的继承"><span class="nav-number">1.11.</span> <span class="nav-text">十一、原型链的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十二、进程与线程"><span class="nav-number">1.12.</span> <span class="nav-text">十二、进程与线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十三、面向对象编程（OOP）"><span class="nav-number">1.13.</span> <span class="nav-text">十三、面向对象编程（OOP）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十四、柯理化函数编程思想"><span class="nav-number">1.14.</span> <span class="nav-text">十四、柯理化函数编程思想</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">徐宇颂</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>









<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共78.8k字</span>
</div>






        
<div class="busuanzi-count">

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
