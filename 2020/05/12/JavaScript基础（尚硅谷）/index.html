<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JavaScript," />










<meta name="description" content="JavaScript的基本介绍 ECMAScript是JavaScript（一门基于对象的、运行在客户端的脚本语言）标准，一般情况下认为是一个意思。一个完整的JavaScript实现应该由以下三个部分构成：  ECMAScript：由ECMA-262定义，提供核心语言功能 DOM：将页面映射为一个多层节点结构，并提供访问和操作网页内容的方法和接口 BOM：提供与浏览器交互的方法和接口  JavaS">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript基础（尚硅谷）">
<meta property="og:url" content="http://easonxys.github.io/2020/05/12/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/index.html">
<meta property="og:site_name" content="Amazing">
<meta property="og:description" content="JavaScript的基本介绍 ECMAScript是JavaScript（一门基于对象的、运行在客户端的脚本语言）标准，一般情况下认为是一个意思。一个完整的JavaScript实现应该由以下三个部分构成：  ECMAScript：由ECMA-262定义，提供核心语言功能 DOM：将页面映射为一个多层节点结构，并提供访问和操作网页内容的方法和接口 BOM：提供与浏览器交互的方法和接口  JavaS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://easonxys.github.io/2020/05/12/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/applyCallBind.png">
<meta property="og:image" content="http://easonxys.github.io/2020/05/12/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/mouseover%E5%92%8Cmouseenter%E7%9A%84%E5%8C%BA%E5%88%AB.png">
<meta property="article:published_time" content="2020-05-12T04:12:05.000Z">
<meta property="article:modified_time" content="2020-07-29T06:37:00.684Z">
<meta property="article:author" content="Eason">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://easonxys.github.io/2020/05/12/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/applyCallBind.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://easonxys.github.io/2020/05/12/JavaScript基础（尚硅谷）/"/>





  <title>JavaScript基础（尚硅谷） | Amazing</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Amazing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">春有百花秋有月 夏有凉风冬有雪</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://easonxys.github.io/2020/05/12/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/caticon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Amazing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript基础（尚硅谷）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-12T12:12:05+08:00">
                2020-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  24.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  91
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>JavaScript的基本介绍</strong></p>
<p>ECMAScript是JavaScript（一门基于对象的、运行在客户端的脚本语言）标准，一般情况下认为是一个意思。一个完整的JavaScript实现应该由以下三个部分构成：</p>
<ul>
<li>ECMAScript：由ECMA-262定义，提供核心语言功能</li>
<li>DOM：将页面映射为一个多层节点结构，并提供访问和操作网页内容的方法和接口</li>
<li>BOM：提供与浏览器交互的方法和接口</li>
</ul>
<p><strong>JavaScript的特点</strong></p>
<ul>
<li><p>解释性语言（无需编译，写完直接由上向下运行）</p>
</li>
<li><p>类似于C和Java的语法结构</p>
</li>
<li><p>动态语言（动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 ）</p>
</li>
<li><p>基于原型的面向对象</p>
</li>
</ul>
<p><strong>script的放置位置</strong></p>
<p>虽然浏览器是多线程的，但是JS是单线程的，如果在&lt;head&gt;标签中添加所有JavaScript文件，就意味着必须等到全部JavaScript代码都被下载，解析和执行完成以后，才能呈现页面的内容（浏览器在遇到&lt;body&gt;标签时才开始呈现内容，而在此之间，浏览器窗口将是一片空白。为了不引起浏览器阻塞，建议将&lt;script&gt;标签放置在页面尾部）</p>
<a id="more"></a>

<h3 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h3><h4 id="一、字面量、变量、标识符"><a href="#一、字面量、变量、标识符" class="headerlink" title="一、字面量、变量、标识符"></a>一、字面量、变量、标识符</h4><p><strong>字面量</strong>：是一些不可变的值，如1，2，3，“hello”；字面量是可以直接使用的，但是一般不会直接使用</p>
<p><strong>变量</strong>：可以用来保存字面量，而且变量的值是可以任意改变的，通过变量保存字面量，并对变量进行描述， 方便开发使用</p>
<p>在JS中可以人为自主命名的都可以称为标识符（变量名、函数名、属性名），命名一个标识符时需要遵守如下规则：</p>
<ol>
<li>标识符中可以含有字母、数字、_ 、$<ul>
<li>基于$开头：一般代表使用jQuery或者其他使用$的类库获取的内容</li>
<li>基于_开头：一般代表是全局或者公共的变量</li>
</ul>
</li>
<li>标识符不能以数字开头，要分隔单词时，可以使用_或者驼峰，但是不能使用 -</li>
<li>标识符不能时ES中的关键字或保留字</li>
<li>标识符一般采用驼峰命名法（如：helloWorld ）</li>
</ol>
<p>ES底层保存标识符时实际上使用的时Unicode编码，所以理论上，所有的utf-8中含有的内容都可以作为标识符</p>
<p><strong>严格模式</strong></p>
<p>顾名思义，就是使JavaScript在更加严格的语法条件下运行。 </p>
<p>通过在全局或函数的开头定义一条<code>&#39;use strict&#39;;</code>进行使用，其目的在于</p>
<ul>
<li>消除JavaScript语法的一些不合理、不严谨之处，减少一些怪异行为</li>
<li>消除代码运行的一些不安全之处。为代码的安全运行保驾护航</li>
<li>为未来新版本的JavaScript做好铺垫</li>
</ul>
<p>严格模式下，语法和行为都有了如下改变：</p>
<ul>
<li>必须用var声明变量</li>
<li>禁止自定义的函数中的this指向window</li>
<li>创建eval作用域</li>
<li>对象不能有重名的属性</li>
</ul>
<p><small>eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。</small></p>
<p><small>如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。</small></p>
<h4 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h4><p>数据类型指的就是字面量的类型，在JS中有六种字符类型：String（字符串）、Number（数值）、Boolean（布尔值）、Null（空值）、Undefined（未定义）、Object（对象）。其中，前五种属于基本数据类型，而Object属于引用数据类型。在ES6中增加了Symbol唯一值类型，也是基本数据类型。</p>
<ul>
<li><strong>String类型</strong></li>
</ul>
<blockquote>
<p>数值、布尔值、对象和字符串值都有toString()方法（字符串值的toString(）方法返回它的一个副本）。但是null和undefined没有这个方法。多数情况下，调用toString()不必传递参数。但是在调用数值的toString()方法时，可以传递一个参数：输出数值的基数。默认情况下，toString()方法以十进制格式返回数值的字符串表示。而通过传递基数，toString()可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值<br>console.log((10).toString(2));            //1010</p>
</blockquote>
<p>转义符</p>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#39;</td>
<td align="left">单引号</td>
</tr>
<tr>
<td align="left">&quot;</td>
<td align="left">双引号</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">反斜杠</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">tab(制表符)</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格符</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页符</td>
</tr>
</tbody></table>
<ul>
<li><strong>Number类型</strong></li>
</ul>
<p>在JS中所有的数值都是Number类型，包括整数和浮点数。在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换为十进制数值。在JS中整数的运算基本可以保证精确，如果使用JS进行浮点运算，可能得到一个不精确的结果。所以千万不要使用JS进行精度要求较高的运算。</p>
<blockquote>
<p>关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于IEEE754数值的浮点计算的通病，ECMAScript并非独此一家；其他使用相同数据格式的语言也存在这种问题（0.1+0.2=0.30000000000000004）</p>
</blockquote>
<p>JS中可以表示的数字的最大值Number.MAX_VALUE <small>可以表示的最小正数为Number.MIN_VALUE</small>，如果使用Number表示的数字超过了最大值，则会返回一个Infinity（正无穷）<small>负无穷为-Infinity</small>，使用typeof检查，返回number</p>
<p><u>NaN</u>是一个特殊的数字，表示Not a Number，使用typeof检查，返回number；NaN和任何值都不相等，包括它自己</p>
<p><strong>其他进制的数字</strong></p>
<p>在JS中，如果需要表示16进制的数字，则需要以<code>0x</code>开头；如果需要表示8进制的数字，则需要以<code>0</code>开头；如果需要表示2进制的数字，则需要以<code>0b</code>开头，但不是所有的浏览器都支持（IE低版本不支持）。像“070”这种字符串，有些浏览器会当成8进制解析，有些会当成10进制进行解析。可以使用<code>parseInt(&quot;070&quot;,10)</code>来指定数字的进制</p>
<blockquote>
<p>可以为parseInt()提供第二个参数：转换时使用的基数（即多少进制）。</p>
<p>如果知道要解析的值是二进制的字符串，那么指定基数作为第二参数，可以保证得到正确的结果<br>console.log(parseInt(“1010”,2));</p>
</blockquote>
<ul>
<li><p><strong>Boolean类型</strong></p>
</li>
<li><p><strong>Null、Undefined类型</strong></p>
</li>
</ul>
<p>Null（空指针对象）类型的值只有1个，就是null，null这个值专门用来表示一个为空的对象。使用typeof检查，返回object</p>
<p>Undefined（声明但未赋值）类型的值只有1个，就是undefined。当声明一个变量，但是未赋值时，它的值就是undefined。使用typeof检查，返回undefined</p>
<blockquote>
<p>其实null不是对象，虽然typeof null会输出object，但这只是JS存在的一个悠久的bug。在JS的最初版本中使用的32位系统，为了性能考虑使用低位，存储变量的类型信息，000开头的代表对象，然而null表示全为零，所以将其错误判断位object</p>
</blockquote>
<p><strong>数据类型转换</strong></p>
<ul>
<li><p>将其他的数据类型转换为String</p>
<ol>
<li><p>调用转换数据类型的toString()方法</p>
<p>该方法不会影响到原变量，它会将转换的结果返回。</p>
<p>但是得注意：null和undefined这两个值是没有toString()方法的，如果强行调用，会报错；</p>
</li>
<li><p>调用String()函数</p>
<p>对于Number和Boolean实际上就是调用的toString()方法；</p>
<p>但是对于null和undefined，就不会调用toString()方法。它会将null和undefined直接转换为”null”和”undefined”</p>
</li>
</ol>
<ul>
<li><p>将其他的数据类型转换为Number</p>
<ol>
<li><p>调用Number()函数</p>
<p><u>字符串–&gt;数字</u>：如果是纯数字的字符串，则直接将其转换为数字；如果字符串中有非数字的内容，则转换为NaN；如果字符串是一个空串或者是一个全是空格的字符串，则转化为0</p>
<p><u>布尔值–&gt;数字</u>：true转换为1；false转换为0</p>
<p><u>Null转换为0；undefined转化为NaN</u></p>
</li>
<li><p>调用parseInt()或者parseFloat()函数（专门针对字符串）</p>
<p>parseInt()可以将一个字符串中有效的整数内容取出，然后转换为Number（也可用于对数值取整）；</p>
<p>parseFloat()可以将一个字符串中有效的整数和小数内容取出，然后转换为Number。</p>
<p>注意：如果对非String类型使用parseInt()或者parseFloat()，它会首先将其转换为String，然后再操作</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>将其他的数据类型转换为Boolean</p>
<ol>
<li><p>调用Boolean()函数</p>
<p><u>数字–&gt;布尔值</u>：除了0和NaN，都是true</p>
<p><u>字符串–&gt;布尔值</u>：除了空串，都是true</p>
<p><u>Null和undefined：都是转换为false</u></p>
<p>对象也会转换为true</p>
</li>
<li><p>隐式类型转换：</p>
<p>为任意的数据类型做两次非运算，即可将其转换为布尔值</p>
</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">原始值</th>
<th align="left">==&gt;Number</th>
<th align="left">==&gt;String</th>
<th align="left">==&gt;Boolean</th>
</tr>
</thead>
<tbody><tr>
<td align="left">false</td>
<td align="left">0</td>
<td align="left">“false”</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">true</td>
<td align="left">1</td>
<td align="left">“true”</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><strong>0</strong></td>
<td align="left"><strong>0</strong></td>
<td align="left"><strong>“0”</strong></td>
<td align="left"><strong>false</strong></td>
</tr>
<tr>
<td align="left"><strong>1</strong></td>
<td align="left"><strong>1</strong></td>
<td align="left"><strong>“1”</strong></td>
<td align="left"><strong>true</strong></td>
</tr>
<tr>
<td align="left">“0”</td>
<td align="left">0</td>
<td align="left">“0”</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">“000”</td>
<td align="left">0</td>
<td align="left">“000”</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">“1”</td>
<td align="left">1</td>
<td align="left">“1”</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><strong>NaN</strong></td>
<td align="left"><strong>NaN</strong></td>
<td align="left"><strong>“NaN”</strong></td>
<td align="left"><strong>false</strong></td>
</tr>
<tr>
<td align="left">Infinity</td>
<td align="left">Infinity</td>
<td align="left">“Infinity”</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">-Infinity</td>
<td align="left">-Infinity</td>
<td align="left">“-Infinity”</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><strong>“”</strong></td>
<td align="left"><strong>0</strong></td>
<td align="left"><strong>“”</strong></td>
<td align="left"><strong>false</strong></td>
</tr>
<tr>
<td align="left">“20”</td>
<td align="left">20</td>
<td align="left">“20”</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">“Runoob”</td>
<td align="left">NaN</td>
<td align="left">“Runoob”</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><strong>[ ]</strong></td>
<td align="left"><strong>0</strong></td>
<td align="left"><strong>“”</strong></td>
<td align="left"><strong>true</strong></td>
</tr>
<tr>
<td align="left"><strong>{ }</strong></td>
<td align="left"><strong>NaN</strong></td>
<td align="left"><strong>“[object Object]”</strong></td>
<td align="left"><strong>true</strong></td>
</tr>
<tr>
<td align="left"><strong>注意</strong></td>
<td align="left">如果将空数组[]与布尔值false比较，false转化为0，而空数组[]也转化为0，因此[] == false的判断得到true。</td>
<td align="left">如果将空对象{}与布尔值false比较，false转化为0，而空对象{}转化为NaN，由于NaN与任何数都不相等，因此{} == false的判断得到false。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">[20]</td>
<td align="left">20</td>
<td align="left">“20”</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">[10,20]</td>
<td align="left">NaN</td>
<td align="left">“10,20”</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">[“Runoob”]</td>
<td align="left">NaN</td>
<td align="left">“Runoob”</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">[“Runoob”,”Google”]</td>
<td align="left">NaN</td>
<td align="left">“Runoob,Google”</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">function(){}</td>
<td align="left">NaN</td>
<td align="left">“function(){}”</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><strong>null</strong></td>
<td align="left"><strong>0</strong></td>
<td align="left"><strong>“null”</strong></td>
<td align="left"><strong>false</strong></td>
</tr>
<tr>
<td align="left"><strong>undefined</strong></td>
<td align="left"><strong>NaN</strong></td>
<td align="left"><strong>“undefined”</strong></td>
<td align="left"><strong>false</strong></td>
</tr>
</tbody></table>
<h4 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h4><p>运算符也叫操作符，通过运算符可以对一个或者多个值进行运算，比如 typeof就是运算符，可以获得一个值的类型，它会将该值的类型以字符串的形式返回</p>
<p><strong>算术运算符</strong>（+ - * / %）：当对非Number类型的值进行运算（加法运算需要特殊考虑）时，会将这些值转换为Number然后再运算；任何与NaN作运算，返回都是NaN。</p>
<p>可以利用这一特点做<u>隐式类型转换</u>，可以通过为一个值 <code>-0 *1 /1</code> 来转换为Number；也可以通过对一个其他数据类型使用<code>+</code>（正号），来将其转换为Number，它的原理和Number()函数一样</p>
<p>如果对两个字符串进行加法运算，则会做拼串操作并返回； 任何的值和字符串做加法运算，都会转换为字符串然后进行拼串</p>
<p><strong>自增</strong>++：无论是a++，还是++a，都会立即使原变量的值自增1，不同的是a++先赋值再自增，++a是先自增再赋值。使用++运算符时（无论前置还是后置），如果变量不是数字模型，会首先使用Number()转换为数字。</p>
<p><strong>自减</strong>–：同上</p>
<p><strong>逻辑运算符</strong>（&amp;&amp; || ！）：对于布尔值进行与或运算，会将其转换为布尔值，然后再运算，<u>并返回原值</u></p>
<p><strong>短路运算</strong>：JS中的“与”属于短路的“与”，如果第一个值为false，则不会看第二个，直接返回false；JS中的“或”属于短路的“或”，如果第一个值为true，则不会看第二个，直接返回true；</p>
<p>在JS函数中我们经常会使用到短路运算符，主要是逻辑与（&amp;&amp;） 和 逻辑或（||）</p>
<ol>
<li>逻辑与 &amp;&amp; 的运算方式</li>
</ol>
<p>如果逻辑与运算符左边的值布尔转换后为true，那么返回右边的值（不管右边的值是真还是假）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span> &amp;&amp; <span class="number">6</span>;	</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//返回的结果为 6</span></span><br></pre></td></tr></table></figure>

<p>如果逻辑与运算符左边的值布尔转换后为false，那么返回左边的值，但是当逻辑与的左边为 null/NaN/undefined ，结果就会得到null/NaN/undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">false</span> &amp;&amp; <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//返回的结果为 false</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>逻辑或 || 的运算方式</li>
</ol>
<p>如果逻辑或运算符左边的值布尔转换后为false，那么返回右边的值（不管右边的值是真还是假）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">false</span> || <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//返回的结果为 6</span></span><br></pre></td></tr></table></figure>

<p>如果逻辑或运算符左边的值布尔转换后为true，那么返回左边的值，如果两个操作数都是null（NaN/undefined），返回null（NaN/undefined）</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span> || <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//返回的结果为 true</span></span><br></pre></td></tr></table></figure>

<p><strong>赋值运算符</strong>（+=，-=）</p>
<p><strong>关系运算符</strong>（&gt; , &gt;= , &lt; , &lt;= ）：对于非数值进行比较，会将其转换为数字然后进行比较；任何值与NaN比较都返回false；如果符号两侧的值都是字符串，不会将其转换为数字进行比较，而会分别比较字符串中字符的Unicode码，比较字符编码时是一位一位进行比较，从第一位开始比较，如果第一位就比较出结果，则直接返回该结果，如果两位一样，则比较下一位。</p>
<p><strong>比较特殊的相等运算符</strong>（==）：</p>
<ul>
<li>​        数值与字符串、布尔值、对象相比较，都会转换为数值，然后再比较；</li>
</ul>
<ul>
<li>​        对象与字符串相比较时，对象会转换为字符串类型，然后再比较；</li>
</ul>
<ul>
<li>​        null与0（或者undefined和0）进行相等判断返回false；</li>
</ul>
<ul>
<li>​        <u>undefined衍生自null，两者进行相等判断，返回true；</u></li>
</ul>
<ul>
<li>​        NaN不和任何值相等，包括它自己（但是可以调用isNaN()函数判断某值是否为NaN，返回值为布尔值）</li>
</ul>
<p>注意：在比较两个字符串型的数字时，一定要转型为Number</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">==</td>
<td align="left">等于（值相等；如果两个变量类型不相同，自动转换成相同类型后再比较）</td>
</tr>
<tr>
<td align="left">===</td>
<td align="left">绝对等于（值和类型均相等，<small>该符号不会进行类型转换</small>）</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="left">!==</td>
<td align="left">不绝对等于（值和类型有一个不相等，或两个都不相等，<small>该符号不会进行类型转换</small>）</td>
</tr>
</tbody></table>
<p><strong>Unicode编码</strong>：在字符串中使用转义字符输入Unicode编码，<code>\u四位编码</code>（四位编码是十六进制）；在网页中使用Unicode编码，<code>&amp;#编码</code>（编码是十进制）</p>
<p><strong>条件运算符（三元运算符）</strong></p>
<p><code>条件？成立处理的事情：不成立处理的事情;</code>在条件成立或者不成立的时候，如果不想做一些事情，可以使用null/ undefined 等来占位（一般使用null，不占位会报错）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = (expression1)  ?  (expression2)  :  (expression3)</span><br><span class="line"><span class="comment">/*在 expression1 逻辑判断为 true 时值为 expression2 ，在expression1 逻辑判断是 false 时值为  expression3。*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a =<span class="number">300</span>;	<span class="keyword">var</span> b=<span class="number">143</span>;	<span class="keyword">var</span> c=<span class="number">50</span>;</span><br><span class="line"><span class="keyword">var</span> max = a &gt; b ? (a &gt; c ? a : c) : (b &gt; c ? b : c);</span><br><span class="line"><span class="comment">//求最大值max：如果a&gt;b且a&gt;c，则max=a；如果a&gt;b但a&lt;=c,则max=c；如果a&lt;=b且b&gt;c，则返回b；如果a&lt;=b,但b&lt;=c，则返回c</span></span><br></pre></td></tr></table></figure>

<p><strong>运算符</strong>：可以使用该运算符同时声明多个变量并赋值</p>
<p><strong>运算符的优先级</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">运算符优先级</a></p>
<h4 id="四、代码块"><a href="#四、代码块" class="headerlink" title="四、代码块"></a>四、代码块</h4><p>JS程序是由一条条语句构成的，语句使按照自上向下的顺序一条条执行。在JS中，可以使用<code>{}</code>来为语句进行分组。同一个<code>{}</code>中的语句称为一组语句，或者叫代码块。它们要么都执行，要么都不执行，在代码块后就不用再加分号。<strong>JS中的代码块，只具有分组的功能，没有其他用途</strong>。</p>
<h4 id="五、流程控制语句"><a href="#五、流程控制语句" class="headerlink" title="五、流程控制语句"></a>五、流程控制语句</h4><p>语句分类：</p>
<ol>
<li><p>条件判断语句（if语句）</p>
<p>if语句只能控制紧随其后的那个语句，如果希望if语句可以控制多条语句，可以将这些语句统一放到代码块中</p>
</li>
<li><p>条件分支语句（switch语句）</p>
<p>在执行时会一次将case后的表达式的值与switch后的条件表达式的值进行全等（===）比较。</p>
</li>
<li><p>循环语句（while语句 for语句）</p>
<p>如果在for循环中不写任何表达式，只写两个分号，此时循环是一个死循环会一直执行，慎用</p>
</li>
</ol>
<p><strong>break、continue</strong></p>
<p>break关键字只能用来退出switch或循环语句，不能在if语句中使用break和continue。break关键字会立即终止离它最近的那个循环语句，步长累计也不执行。</p>
<p>continue关键字会跳过当次循环，而不会跳出整个循环，continue关键字也会立即终止离它最近的那个循环语句，步长累计仍会执行。</p>
<p>除此之外，还可以使用给语句定义标签，完成break或continue的“指定跳出”而不是最近跳出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*通过给语句定义标签，就可以在程序的任何地方通过标签名来引用这条语句*/</span></span><br><span class="line">label: statements</span><br><span class="line"><span class="comment">/*break和continue语句使仅有的可以“跳出”代码块的语句*/</span></span><br><span class="line"><span class="keyword">break</span> labelname;</span><br><span class="line"><span class="keyword">continue</span> labelname;</span><br></pre></td></tr></table></figure>

<h4 id="六、对象"><a href="#六、对象" class="headerlink" title="六、对象"></a>六、对象</h4><p>String（字符串）、Number（数值）、Boolean（布尔值）、Null（空值）、Undefined（未定义），以上五种类型属于基本数据类型，之后所接触的值只要不是上述五种，全是对象。</p>
<p>基本数据类型都是单一的值，值和值之间没有任何联系，不能成为一个整体。而对象属于一种复合的数据类型，在对象中可以保存多个不同数据数据类型的属性。</p>
<p><strong>对象的分类</strong>：</p>
<ol>
<li><p><u>内建对象</u></p>
<p>由ES标准实现提供的、不依赖于宿主环境的对象，内置对象（内建对象）在ES程序执行之前就已经存在。比如：<code>Arguments 函数参数集合</code>、 <code>Array 数组对象</code>、 <code>Boolean 布尔对象</code>、<code>Date 日期时间</code>、<code>Error 异常对象</code>、<code>Function 函数构造器</code>、<code>Math 数学对象</code>、<code>Number 数值对象</code>、<code>Object 基础对象</code>、<code>RegExp 正则表达式对象</code>、<code>String 字符串对象</code>。除此之外ECMA-262还定义了两个单体内置对象：<code>Global对象</code> 和 <code>Math对象</code></p>
</li>
<li><p><u>宿主对象</u></p>
<p>由JS的运行环境提供的对象，目前来讲主要是由浏览器提供的对象。比如 BOM，DOM</p>
</li>
<li><p><u>自定义对象</u>，由开发人员创建的对象</p>
</li>
</ol>
<p><strong>自定义对象</strong></p>
<p>使用键值对 <code>{key:value}</code>来描述一个对象的特征，每一个对象都是综合体，存在零到多组键值对。key不能使引用数据类型，value可以使任何的数据类型，每组键值对使用逗号分隔</p>
<ol>
<li><p>创建对象</p>
<p><code>var object = new Object();</code>，使用new关键字调用的函数，是构造函数constructor。构造函数是专门用来创建对象的函数，使用typeof检查一个对象时，会返回object</p>
</li>
<li><p>添加属性</p>
<p>在对象中保存的值称为属性。<code>对象.属性名 = 属性值;</code>。JS对象的属性值，可以是任意的数据类型，<u>甚至也可以是对象（包括函数对象）</u>，如果一个函数作为一个对象的属性保存，那么称这个函数是这个对象的方法，调用这个函数就可以说是调用对象的方法（仅是名称上的差别）</p>
<p>对象的属性名不强制要求遵守标识符的规范。如果要使用特殊的属性名，不能采用<code>.属性名</code> 的方式操作，需要使用另一种方式，<code>对象[&quot;属性名&quot;] = 属性值;</code>，相应的读取也得使用这种方式。使用<code>[ ]</code> 这种方法操作属性，更加灵活，在<code>[ ]</code>中可以直接传递一个变量，这样的变量代表什么属性名，就会读取相应的属性</p>
</li>
<li><p>读取属性</p>
<p><code>object.属性名</code>，如果读取对象中没有的属性，不会报错而是会返回undefined。<br><u>in 运算符</u>：通过该运算符可以检查一个对象中是否含有指定的属性，<code>&quot;属性名&quot; in 对象</code> 如果有则返回true，没有则返回false</p>
<p>使用<code>Object.keys(对象)</code>，返回当前对象所有属性名的数组</p>
</li>
<li><p>修改属性，<code>对象.属性名 = 新的属性值;</code></p>
</li>
<li><p>删除属性</p>
<p>真删除：<code>delete 对象.属性名;</code>    彻底将属性从对象中移除</p>
<p>假删除：<code>对象.属性名=null;</code>    当前属性还存在，只不过属性值为空</p>
</li>
</ol>
<p><strong>基本数据类型和引用数据类型</strong></p>
<p>基本类型数据（String、Number、Boolean、Null、Undefined），引用数据类型（Object）。JS中的变量都是保存到栈内存中的</p>
<p>基本数据类型的值直接在栈内存中存储，值与值之间是独立存在的，修改一个变量不会影响其他变量；</p>
<p>引用数据类型的值是保存在堆内存中，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量保存的是对象的内存地址（对象的引用），当两个变量共同指向该内存地址时，一个变量修改属性时，内存地址存储的数据改变，另一个变量也会受到影响。</p>
<p>当比较两者基本数据类型的值时，就是比较值。而比较两个引用数据类型时，它比较的是对象的内存地址，如果两个对象是一模一样的，但是地址不同，它也会返回false。</p>
<p><strong>对象字面量</strong></p>
<p>使用对象字面量来创建一个对象，本质上 <code>var object = {};</code>和<code>var object = new Object();</code>创建对象的方式相同。使用对象字面量，可以在创建对象时，直接指定对象中的属性，<code>var object={属性名1:属性值,属性名2:属性值};</code>对象字面量的属性名可以加引号也可以不加（建议不加），但是如果要使用一些特殊的名字，则必须要加引号</p>
<p><strong>枚举对象中的属性</strong></p>
<ul>
<li><p>使用<code>for ... in</code>语句</p>
<p><code>for ... in</code>语句，对象中有几个属性，循环体就会执行几次。每次执行时，会将对象中的一个属性的名字（键）赋值给变量。如果想通过键得到属性值，则需要使用<code>objext[n]</code>。<code>for ... in</code>遍历对象上除了Symbol以外的可枚举属性，包括原型链上的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> n <span class="keyword">in</span> object)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(object[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>垃圾回收</strong></p>
<p>当一个对象没有任何的变量或属性对它进行引用，此时无法操作该对象，那么它就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须清理。在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们要做的只是将不再使用的对象设置为null</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">object = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><strong>ES5为对象扩展的一些静态方法</strong></p>
<ul>
<li><p><code>Object.create(prototype,[descriptors])</code>：以指定的对象为原型创建新的对象</p>
<p>其中 [descriptors] 是为新的对象指定新的属性，并对属性进行描述</p>
<ul>
<li>value：指定值</li>
<li>writable：标识当前属性值是否可以修改，默认为false</li>
<li>configurable：标识当前属性是否可以被删除，默认为false</li>
<li>enumerable：标识当前属性是否能用  <code>for ... in</code> 枚举，默认为false</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">username</span>:<span class="string">"eason"</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> newobj1=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//newobj2不仅继承了obj的属性方法，还新增、删除、枚举了一些属性</span></span><br><span class="line"><span class="keyword">var</span> newobj2=<span class="literal">null</span>;</span><br><span class="line">newobj2=<span class="built_in">Object</span>.create(obj,&#123;</span><br><span class="line">  sex:&#123;</span><br><span class="line">    value:<span class="string">"male"</span>,</span><br><span class="line">    writable:<span class="literal">true</span>,</span><br><span class="line">    enumerable:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  job:&#123;</span><br><span class="line">    value:<span class="string">"student"</span>,</span><br><span class="line">    configurable:<span class="literal">true</span>,</span><br><span class="line">    enumerable:<span class="literal">true</span>   </span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">newobj2.sex=<span class="string">'男'</span>;</span><br><span class="line"><span class="keyword">delete</span> newobj2.job;</span><br><span class="line"><span class="built_in">console</span>.log(newobj2);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[object Object] &#123;</span></span><br><span class="line"><span class="comment">  age: 18,</span></span><br><span class="line"><span class="comment">  sex: "男",</span></span><br><span class="line"><span class="comment">  username: "eason"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>( i <span class="keyword">in</span> newobj2)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newobj2[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*	"男"		"eason"		18		*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.defineProperties(Object,descriptors)</code>：为指定对象定义扩展多个属性</p>
<ul>
<li>get：用来获取当前属性值的回调函数，获取扩展属性值的时候get()方法自动调用</li>
<li>set：修改当前属性值触发的回调函数，并且实参即为修改后的值</li>
</ul>
<p>存储器属性：setter，getter，一个用来存值，一个用来取值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩展属性、方法</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">username</span>:<span class="string">"eason"</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj,&#123;</span><br><span class="line">  info:&#123;</span><br><span class="line">    <span class="keyword">get</span>:function()&#123;	<span class="comment">//获取扩展属性的值     </span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.username&#125;</span> is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old `</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>:function(data)&#123; </span><br><span class="line">    	data=data.split(<span class="string">" "</span>)</span><br><span class="line">    	<span class="keyword">this</span>.username=data[<span class="number">0</span>];</span><br><span class="line">      	<span class="keyword">this</span>.age=data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.info);		<span class="comment">//eason is 18 years old</span></span><br><span class="line">obj.info=<span class="string">"easonXU 24"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.info);		<span class="comment">//easonXU is 24 years old</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h4><p>函数也是一个对象，函数中可以封装一些功能在需要的时候调用。</p>
<ol>
<li><p>创建函数对象，使用函数声明来进行创建，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种声明方式</span></span><br><span class="line"><span class="comment">/* 形参时JS函数的入口，因此形参是变量。</span></span><br><span class="line"><span class="comment"> * 函数执行时，传递进来的实参会赋值给形参，实参是值*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">[形参<span class="number">1</span>,形参<span class="number">2</span>,...形参n]</span>)</span>&#123;</span><br><span class="line">    语句...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种声明方式</span></span><br><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params">[形参<span class="number">1</span>,形参<span class="number">2</span>,...形参n]</span>)</span>&#123;</span><br><span class="line">    语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><small>(<strong>很少使用</strong>)<code>var fun=new Function(&quot;console.log(&quot;hello world&quot;)&quot;);</code>,使用typeof检查一个函数对象时，会返回function。可以将要封装的代码以字符串的形式传递给构造函数。封装到函数中的代码不会立即执行，会在函数被调用的时候执行</small></p>
</li>
<li><p>函数调用，<code>fun([实参1,实参2,...实参n]);</code>，当调用函数时，函数中封装的代码会按照顺序执行。<u>实参可以使任意的数据类型，可以是一个对象</u>。当参数过多时，可以将参数封装到一个对象中，然后使用对象进行传递。<u>实参甚至可以是一个函数</u></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun([实参<span class="number">1</span>,实参<span class="number">2</span>,...实参n])	<span class="comment">//调用函数，相当于使用的是函数的返回值</span></span><br><span class="line">fun							<span class="comment">//函数对象，相当于直接使用函数对象</span></span><br></pre></td></tr></table></figure>

<p>调用函数时，解析器不会检查实参的类型和数量，所以要注意，是否有可能接收到非法的参数，如果有可能则需要对参数进行类型检查；多余的实参也不会被赋值，但是如果实参的数量少于形参的数量，则没有对象实参的形参将是undefined。</p>
</li>
</ol>
<p><strong>函数的返回值</strong></p>
<p>可以使用return来设置函数的返回值，return之后的语句不会被执行，使用return可以结束整个函数（区别于break和continue）。如果return语句后不跟任何值，就相当于返回一个undefined，如果函数中不写return，则也会返回undefined。返回值可以是任意的数据类型（可以是一个对象包括函数对象）。</p>
<p>值得注意的是如果对return后面跟着的值进行了换行，JavaScript解析器会自动在return后面补加<code>;</code>，导致输出出错。</p>
<ul>
<li><p>return false</p>
<p>在大多数情况下,为事件处理函数返回false,可以防止默认的事件行为.例如,默认情况下点击一个a元素,页面会跳转到该元素href属性指定的页。<u>JS中return false作用一般是用来<strong>取消默认动作 / 阻止提交表单 / 阻止继续执行下面的代码</strong>，相当于终止符。</u>注意：return false 只在当前函数有效，不会影响其他外部函数的执行。</p>
</li>
<li><p>return true</p>
<p>return true <strong>返回正确的处理结果，</strong>就相当于<strong>执行符</strong>。</p>
</li>
<li><p>return</p>
<p>把控制权返回给页面</p>
</li>
</ul>
<p><strong>立即执行函数</strong> IIFE</p>
<p>函数定义完，立即调用，这种函数叫作立即执行函数。立即执行函数往往只会执行一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">[形参<span class="number">1</span>,形参<span class="number">2</span>,...形参n]</span>)</span>&#123;</span><br><span class="line">    语句...</span><br><span class="line">&#125;)([实参<span class="number">1</span>,实参<span class="number">2</span>,...实参n]);</span><br></pre></td></tr></table></figure>

<p><strong>作用域</strong></p>
<p>作用域指的是一个变量的作用范围，在JS中一共有两个全局作用域</p>
<ul>
<li>全局作用域<ul>
<li>直接编写在script标签中的JS代码，都在全局作用域</li>
<li>全局作用域在网页页面打开时创建，在页面关闭时销毁</li>
<li>在全局作用域中有一个全局对象window，代表浏览器窗口，由浏览器创建，可以直接使用</li>
<li>在全局作用域中，创建的变量都会作为window对象的属性保存，创建的函数都会作为window对象的方法保存</li>
<li>全局作用域中的变量都是全局变量，在页面的任意部分都能被访问</li>
</ul>
</li>
<li>局部作用域（函数作用域）<ul>
<li>调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁</li>
<li>每调用一次函数都会创建一个新的函数作用域，它们之间是相互独立的</li>
<li>在函数作用域中，可以访问到全局作用域的变量（全局变量），在全局作用域中无法访问到函数作用的变量（局部变量）</li>
<li>当在函数作用域操作一个变量时，它会首先在自身作用域中寻找，如果有就直接使用，如果没有，就向上一级作用域中寻找，直到在全局作用域中找到。如果全局作用域中依然没有，则会直接报错 ReferenceError</li>
<li>在函数中要想访问全局变量，可以使用window对象</li>
<li>在函数作用域也有变量声明提前的特性，使用var关键字声明的变量，会在函数中所有代码执行之前被声明；同样的，在函数作用域中也有函数声明提前的特性</li>
<li>定义了形参就相当于在函数作用域中声明了变量</li>
<li><strong>注意</strong>：在函数中，如果不使用var关键字声明，同时也无形参进行声明的变量都会成为全局变量</li>
</ul>
</li>
</ul>
<p><strong>变量的声明提前</strong></p>
<p>使用var关键字声明的变量，会在所有的代码执行之间被声明（但是不会赋值），但是如果声明变量时不使用var关键字，则变量不会被声明提前</p>
<p><strong>函数的声明提前</strong></p>
<p>使用函数声明形式创建的函数<code>function fun(){}</code>，它会在所有代码执行前被创建，所以可以在函数声明之前调用函数。而使用函数表达式创建的函数<code>var fun=function(){}</code>，不会被声明提前，所以不能在声明前调用。<small>如果调用函数在它之前，fun会由var关键字的变量声明提前而被声明，但未被赋值，仍为undefined，无法被调用</small></p>
<p><strong>this关键字</strong></p>
<p>解析器在调用函数时，每次都会向函数传递进两个隐含的参数，其中一个是this。this指向的是一个对象，称为函数执行的上下文对象。根据函数的调用方式的不同，this会指向不同的对象。</p>
<ul>
<li>以函数的形式调用时，this永远都是window</li>
<li>以方法的形式调用时，this就是调用方法的那个对象 </li>
<li>以构造函数的形式调用时（使用new关键字），this就是新创建的那个对象</li>
<li>使用call()和apply()调用时，this是指定的那个对象</li>
<li>在事件响应的函数中，this就是响应函数绑定的对象</li>
</ul>
<p><strong>arguments关键字</strong></p>
<p>解析器在调用函数时，每次都会向函数传递进两个隐含的参数，</p>
<ol>
<li>函数的上下文对象this</li>
<li>封装实参的对象arguments（ES6的箭头函数没有 arguments）</li>
</ol>
<p>arguments是一个类数组对象，它的类型是object。<code>typeof arguments =&#39;object&#39;</code>。它也可以通过索引来操作数据，也可以获取长度。在调用函数时，所传递的实参都会在arguments中进行保存。因此即使不定义形参也可以通过arguments来使用实参，只是很麻烦。如 arguments[0]表示第一个实参，arguments[1]表示第二个实参……<u>arguments中还存在一个属性callee，这个属性对应一个函数对象，就是当前正在执行的函数对象。</u></p>
<p><strong>call()和apply()、bind()的区别</strong></p>
<p>⭐面试题：bind、apply、call的区别与联系</p>
<p>call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象()，第二个参数差别就来了：</p>
<ul>
<li><u>call的参数是直接放进去的</u>，第二第三第n个参数全都用逗号分隔，直接放到后面</li>
<li>apply的所有参数都<u>必须放在一个数组里面传进去</u>  </li>
<li>bind除了返回是函数以外，它的参数和call 一样。值得注意的是 ，bind一般与回调函数搭配使用，且与上述两个函数不同，使用bind绑定后不会立即调用当前函数，而是将函数返回</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">  name:<span class="string">"eason"</span>,</span><br><span class="line">  age:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>,str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入参数的形式</span></span><br><span class="line">fun.call(obj,<span class="string">"hello"</span>);	<span class="comment">//直接从第二个参数开始，依次传入</span></span><br><span class="line">fun.apply(obj,[<span class="string">"hello"</span>]); <span class="comment">//第二个参数必须是数组，实参放到数组中</span></span><br><span class="line">fun.bind(obj,<span class="string">"hello"</span>)();<span class="comment">//bind的特点：绑定后this不会立即调用当前的函数，而是将函数返回。传参形式与call方法一致</span></span><br><span class="line"> </span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;.bind(obj),<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<img src="/2020/05/12/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/applyCallBind.png">



<p><strong>构造函数</strong></p>
<p>构造函数就是一个普通的函数，创建方式和普通函数没有区别。不同的是构造函数习惯上首字母大写，调用方式也不同，普通函数就是直接调用，而构造函数需要使用new关键字调用。</p>
<p>构造函数的执行流程：</p>
<ol>
<li>立即创建一个新的对象</li>
<li>将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象</li>
<li>逐行执行函数中的代码</li>
<li>将新建的对象作为返回值返回</li>
</ol>
<p>在JavaScript构造函数中：默认情况下，我们的构造函数是没有return语句的，构造函数里面的this会指向将来实例化对象的，也就是new Object()后的对象。但是假如return基本数据类型，那么对构造函数没有影响，实例化对象返回空对象；如果return引用类型（数组，函数，对象），那么实例化对象就会返回该引用类型；</p>
<p>使用同一个构造函数创建的对象，称为一类对象，也将一个构造函数称为一个类。我们将通过一个构造函数创建的对象，称为该类的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个新的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,gender</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//将新建的对象设置为函数中的this，</span></span><br><span class="line">    <span class="comment">//（被调用时）逐行执行函数中的代码，此处通过this给该对象添加属性</span></span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.gender=gender;</span><br><span class="line">    <span class="keyword">this</span>.sayHello=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"Hello, I am "</span>+<span class="keyword">this</span>.name+</span><br><span class="line">            <span class="string">" ,I am "</span>+<span class="keyword">this</span>.age+<span class="string">" years old."</span>+</span><br><span class="line">            <span class="string">" My gender is "</span>+<span class="keyword">this</span>.gender+<span class="string">"."</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用new关键字进行调用，返回新建的对象</span></span><br><span class="line"><span class="keyword">var</span> per=<span class="keyword">new</span> Person(<span class="string">"Eason"</span>,<span class="number">18</span>,<span class="string">"male"</span>);</span><br><span class="line">per.sayHello();</span><br></pre></td></tr></table></figure>

<p>使用 instanceof 可以检查一个对象是否是一个类的实例 <code>console.log(per instanceof Person);</code>，如果是，则返回true，反之返回false。</p>
<p><strong>原型</strong></p>
<p>创建的每一个函数，解析器都会在函数中添加一个属性 prototype。这个属性对应着一个对象——原型对象。如果函数作为普通函数调用，prototype没有任何作用。当函数以构造函数（类）的形式调用是，它所创建的对象（实例）都会有一个隐含的属性<code>__proto__</code>，指向构造函数的原型对象方便我们进行访问。</p>
<p>原型对象就相当于一个公共的区域，所有同一类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。当需要访问实例对象的属性或者方法时，它会先在实例对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有，就去原型对象的原型中寻找，直到找到Object对象的原型（Object<strong>对象的原型没有原型，或者说是null</strong>），如果还没有，则返回undefined。</p>
<p>以后创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,gender</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.gender=gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> per=<span class="keyword">new</span> Person(<span class="string">"Eason"</span>,<span class="number">18</span>,<span class="string">"male"</span>);</span><br><span class="line"><span class="comment">//使用原型对象添加类的方法</span></span><br><span class="line">Person.prototype.sayHello2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello, it's me again. "</span>+<span class="keyword">this</span>.name+</span><br><span class="line">    <span class="string">", a  "</span>+<span class="keyword">this</span>.gender+<span class="string">" with "</span>+<span class="keyword">this</span>.age+<span class="string">" years old."</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">per.sayHello2();</span><br></pre></td></tr></table></figure>

<p><u>使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中含有，也会返回true。可以使用hasOwnProperty() 来检查对象自身中是否含有某属性。</u></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"使用in运算符在原型链中查找"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> per);										<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"使用hasOwnProperty()在对象中寻找"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(per.__proto__.__proto__.hasOwnProperty(<span class="string">"toString"</span>));	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>toString()函数的重构</strong></p>
<p>如果使用toString()函数打印一个对象的时候，事件输出的是<code>[object Object]</code>。如果希望得到详细输出，则需要对toString()进行重构</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>函数的方法</strong></p>
<p>call()和apply()这两个方法都是函数对象的方法，需要通过函数对象来调用。当对函数调用call()和apply()都会调用函数执行。<u>调用call()和apply()可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行的this</u>。</p>
<ul>
<li>call()方法可以将实参在对象之后依次传递</li>
<li>apply()方法需要将实参封装到一个数组中统一传递</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  fullName: <span class="function"><span class="keyword">function</span>(<span class="params">city, country</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName + <span class="string">","</span> + city + <span class="string">","</span> + country;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  firstName:<span class="string">"Bill"</span>,</span><br><span class="line">  lastName: <span class="string">"Gates"</span></span><br><span class="line">&#125;</span><br><span class="line">person.fullName.call(person1, <span class="string">"Seattle"</span>, <span class="string">"USA"</span>);	<span class="comment">//Bill Gates,Seattle,USA</span></span><br><span class="line">person.fullName.apply(person1,[<span class="string">"Seattle"</span>,<span class="string">"USA"</span>]);	<span class="comment">//Bill Gates,Seattle,USA</span></span><br></pre></td></tr></table></figure>

<h4 id="八、数组（内建对象）"><a href="#八、数组（内建对象）" class="headerlink" title="八、数组（内建对象）"></a>八、数组（内建对象）</h4><p>数组也是一个对象，和普通对象功能类似。不同的是普通对象是使用字符串来作为属性名，而数组使用数字来作为索引（从0开始）操作元素。数组中的元素可以是任意的数据类型。使用typeof检查一个数组时，会返回object。</p>
<p>使用 <code>var arr = new Array();</code>或者使用字面量<code>var arr=[];</code>来创建数组，使用 <code>arr[索引]</code>来读取数组，如果读取不存在的索引，并不会报错而是返回undefined。</p>
<p>获取连续数组的长度（元素个数）：<code>arr.length</code>，对于非连续数组，使用length会获取数组的最大索引+1。如果修改的length大于原来的长度，则多出部分会空出来；如果修改的length小于原来的长度，则多余元素会被删除，因此可以使用<code>arr.length--</code>的方法删除数组末尾一项</p>
<p><strong>数组的方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>concat()</strong></td>
<td align="left"><strong>连接两个或更多的数组，并返回结果。</strong>该方法不会影响原数组</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">方法与 <code>arr=[...arrA,...arrB,...arrC]</code>一致</td>
</tr>
<tr>
<td align="left"><strong>copyWithin()</strong></td>
<td align="left"><strong>从数组的指定位置拷贝元素到数组的另一个指定位置中，原数组元素会被复制元素所覆盖。</strong></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>arr.copyWithin(target, start, end)</code> target是必需。表示复制到指定目标索引的位置，start 和 end 分别表示元素复制的起始位置和停止复制的索引位置。如果end为负值，表示倒数</td>
</tr>
<tr>
<td align="left"><strong>entries()</strong></td>
<td align="left"><strong>返回数组的可迭代对象。</strong>是keys()和values()方法的综合</td>
</tr>
<tr>
<td align="left"><strong>every()</strong></td>
<td align="left"><strong>检测数值元素的每个元素是否都符合条件。</strong>返回值为布尔值。如果所有元素都通过检测返回 true，否则返回 false。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>arr.every(function(currentValue,index,arr), thisValue)</code></td>
</tr>
<tr>
<td align="left"><strong>fill()</strong></td>
<td align="left"><strong>使用一个固定值来填充数组。</strong></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>arr.fill(value, start, end)</code>在数组下标∈[start,end)中填充value，其中 start 和 end 为可选变量</td>
</tr>
<tr>
<td align="left"><strong>filter()</strong></td>
<td align="left"><strong>检测数值元素，并返回符合条件所有元素的数组。</strong>返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>arr.filter(function(currentValue,index,arr), thisValue)</code></td>
</tr>
<tr>
<td align="left"><strong>find()</strong></td>
<td align="left"><strong>返回第一个符合传入测试（函数）条件的数组元素的值。当数组中的元素在测试条件时返回 *true* 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 undefined</strong></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>arr.find(function(currentValue, index, arr),thisValue)</code>其中function( … )为必需，是数组中每个元素都需要执行的函数。currentValue 必需，为当前元素；index 可选，为当前元素的索引值；arr 可选，为当前元素所属的数组对象；thisValue 可选。传递给函数的值一般用“this”值，如果该参数为空，“undefined”会传递给“this”值</td>
</tr>
<tr>
<td align="left">findIndex()</td>
<td align="left">返回第一个符合传入测试（函数）条件的数组元素索引。</td>
</tr>
<tr>
<td align="left"><strong>forEach()</strong></td>
<td align="left"><strong>数组每个元素都执行一次回调函数。</strong></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>arr.forEach(function(currentValue, index, arr), thisValue)</code> 其中function( … )为必需，是数组中每个元素都需要调用的函数。currentValue 必需，为当前元素；index 可选，为当前元素的索引值；arr 可选，为当前元素所属的数组对象；thisValue 可选。传递给函数的值一般用“this”值，如果该参数为空，“undefined”会传递给“this”值</td>
</tr>
<tr>
<td align="left">from()</td>
<td align="left">通过给定的对象中创建一个数组。</td>
</tr>
<tr>
<td align="left"><strong>includes()</strong></td>
<td align="left"><strong>判断一个数组是否包含一个指定的值，返回布尔值。</strong></td>
</tr>
<tr>
<td align="left">indexOf()</td>
<td align="left">搜索数组中的元素，并返回它所在的第一个出现的位置。</td>
</tr>
<tr>
<td align="left">isArray()</td>
<td align="left">判断对象是否为数组。</td>
</tr>
<tr>
<td align="left"><strong>join()</strong></td>
<td align="left"><strong>把数组的所有元素放入一个字符串并返回。</strong>join()中可以指定一个字符串作为参数用于数组中元素的连接符，该方法不会影响原数组。join()方法如果省略参数，默认以<code>,</code>分隔</td>
</tr>
<tr>
<td align="left"><strong>keys()</strong></td>
<td align="left"><strong>返回数组的可迭代对象，包含原始数组的键(key)。</strong></td>
</tr>
<tr>
<td align="left"><strong>values()</strong></td>
<td align="left"><strong>返回数组的可迭代对象，包含原始数组的值(value)。</strong></td>
</tr>
<tr>
<td align="left">lastIndexOf()</td>
<td align="left">搜索数组中的元素，并返回它最后出现的位置。</td>
</tr>
<tr>
<td align="left"><strong>map()</strong></td>
<td align="left"><strong>通过指定函数处理数组的每个元素，返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。原数组保持不变。</strong></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>arr.map(function(currentValue,index,arr), thisValue)</code></td>
</tr>
<tr>
<td align="left"><strong>pop()</strong></td>
<td align="left"><strong>删除数组的最后一个元素并返回删除的元素。</strong></td>
</tr>
<tr>
<td align="left"><strong>push()</strong></td>
<td align="left"><strong>向数组的末尾添加一个或更多元素，并返回新的长度。</strong></td>
</tr>
<tr>
<td align="left"><strong>⭐reduce()</strong></td>
<td align="left"><strong>将数组元素计算为一个值（从左到右）。</strong></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>arr.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code> 其中function( … )为必需，是数组中每个元素都需要执行的函数。<strong>total必需。可以规定初始值，或者是计算结束后的返回值</strong>，currentValue 必需，为当前元素；currentIndex 可选，为当前元素的索引值；arr 可选，为当前元素所属的数组对象；initialValue 可选。传递给函数的初始值。如果不设置initialValue，则total从数组中第一个元素开始，cur从数组中第二个元素开始；如果设置了initialValue，则total初始值为initialValue，而cur从数组中第一个元素开始。例如：<br>  const arr=[1,2,3,4,5,6,7,8];<br>  const total=arr.reduce((total,item)=&gt;{<br>    return total+item;<br>  },0);<br>  <br>  console.log(total);      //36</td>
</tr>
<tr>
<td align="left">reduceRight()</td>
<td align="left">将数组元素计算为一个值（从右到左）。</td>
</tr>
<tr>
<td align="left">reverse()</td>
<td align="left">反转数组的元素顺序。该方法会直接修改原数组</td>
</tr>
<tr>
<td align="left"><strong>slice()</strong></td>
<td align="left"><strong>选取数组的的一部分，并返回一个新数组。</strong>不会影响原数组</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>arr.slice(start, end)</code> 返回一个新的数组，包含下标∈[start,end)的元素。start如果是负数，那么它规定从数组尾部开始算起的位置，end如果数是负数，那么它规定的是从数组尾部开始算起的元素。</td>
</tr>
<tr>
<td align="left"><strong>some()</strong></td>
<td align="left"><strong>检测数组元素中是否有元素符合指定条件。</strong>（与every()方法用法相似，只是every()要求数组元素中每一个都得符合指定条件，而some()只需数组元素中的一个满足即可）</td>
</tr>
<tr>
<td align="left"><strong>sort()</strong></td>
<td align="left"><strong>对数组的元素进行排序。</strong>该方法会直接修改原数组</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>arr.sort(sortfunction)</code> 其中 如果sortfunction 为<code>function(a,b){return a-b}</code>，表示从小到大排序，a b顺序互换为从大到小排序。默认按照Unicode编码进行排序，但是如果采用默认方式，可能会产生11小于2的情况</td>
</tr>
<tr>
<td align="left"><strong>splice()</strong></td>
<td align="left"><strong>从数组中添加或删除元素。</strong>如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。<strong>注意：</strong>这种方法会改变原始数组。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>arr.splice(index,howmany,item1,.....,itemX)</code> index为必需，规定从何处添加或删除；howmany 可选，规定要删除的元素个数，如果没有规定此参数，默认从index开始删到数组结尾；item1……可选，表示添加到数组的新元素。</td>
</tr>
<tr>
<td align="left">toString()</td>
<td align="left">把数组转换为字符串，并返回结果。</td>
</tr>
<tr>
<td align="left"><strong>shift()</strong></td>
<td align="left"><strong>删除并返回数组的第一个元素。</strong>删除第一个元素后，其他的元素索引会依次调整</td>
</tr>
<tr>
<td align="left"><strong>unshift()</strong></td>
<td align="left"><strong>向数组的开头添加一个或更多元素，并返回新的长度。</strong>向前边插入元素后，其他的元素索引会依次调整</td>
</tr>
<tr>
<td align="left">valueOf()</td>
<td align="left">返回数组对象的原始值。</td>
</tr>
</tbody></table>
<h4 id="九、Date对象（内建对象）"><a href="#九、Date对象（内建对象）" class="headerlink" title="九、Date对象（内建对象）"></a>九、Date对象（内建对象）</h4><ul>
<li><p><code>var d = new Date();</code></p>
<p>创建一个Date对象，如果直接使用构造函数创建一个Date对象实例，则会封装为当前代码执行的时间</p>
</li>
<li><p><code>var d2 = new Date(&quot;05/08/2020 21:52:55&quot;);</code></p>
<p>创建一个指定的时间对象，需要在构造函数中传递一个表示时间的字符串作为参数。日期格式 <code>MM/DD/YYYY HH:mm:ss</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>getDate()</strong></td>
<td align="left"><strong>从 Date 对象返回一个月中的某一天 (1 ~ 31)。</strong></td>
</tr>
<tr>
<td align="left"><strong>getDay()</strong></td>
<td align="left"><strong>从 Date 对象返回一周中的某一天 (0 ~ 6)。</strong></td>
</tr>
<tr>
<td align="left"><strong>getFullYear()</strong></td>
<td align="left"><strong>从 Date 对象以四位数字返回年份。</strong></td>
</tr>
<tr>
<td align="left">getHours()</td>
<td align="left">返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="left">getMilliseconds()</td>
<td align="left">返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td align="left">getMinutes()</td>
<td align="left">返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left"><strong>getMonth()</strong></td>
<td align="left"><strong>从 Date 对象返回月份 (0 ~ 11)。</strong></td>
</tr>
<tr>
<td align="left">getSeconds()</td>
<td align="left">返回 Date 对象的秒数 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left"><strong>getTime()</strong></td>
<td align="left"><strong>返回时间戳（格林威治时间1970 年 1 月 1 日 0 时 0 分至今的毫秒数）。</strong>计算机底层在保存时间时，使用的都是时间戳。</td>
</tr>
<tr>
<td align="left">getTimezoneOffset()</td>
<td align="left">返回本地时间与格林威治标准时间 (GMT) 的分钟差。</td>
</tr>
<tr>
<td align="left">getUTCDate()</td>
<td align="left">根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="left">getUTCDay()</td>
<td align="left">根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。</td>
</tr>
<tr>
<td align="left">getUTCFullYear()</td>
<td align="left">根据世界时从 Date 对象返回四位数的年份。</td>
</tr>
<tr>
<td align="left">getUTCHours()</td>
<td align="left">根据世界时返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="left">getUTCMilliseconds()</td>
<td align="left">根据世界时返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td align="left">getUTCMinutes()</td>
<td align="left">根据世界时返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left">getUTCMonth()</td>
<td align="left">根据世界时从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="left">getUTCSeconds()</td>
<td align="left">根据世界时返回 Date 对象的秒钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left">parse()</td>
<td align="left">返回1970年1月1日午夜到指定日期（字符串）的毫秒数。</td>
</tr>
<tr>
<td align="left">setDate()</td>
<td align="left">设置 Date 对象中月的某一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="left">setFullYear()</td>
<td align="left">设置 Date 对象中的年份（四位数字）。</td>
</tr>
<tr>
<td align="left">setHours()</td>
<td align="left">设置 Date 对象中的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="left">setMilliseconds()</td>
<td align="left">设置 Date 对象中的毫秒 (0 ~ 999)。</td>
</tr>
<tr>
<td align="left">setMinutes()</td>
<td align="left">设置 Date 对象中的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left">setMonth()</td>
<td align="left">设置 Date 对象中月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="left">setSeconds()</td>
<td align="left">设置 Date 对象中的秒钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left">setTime()</td>
<td align="left">setTime() 方法以毫秒设置 Date 对象。</td>
</tr>
<tr>
<td align="left">setUTCDate()</td>
<td align="left">根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="left">setUTCFullYear()</td>
<td align="left">根据世界时设置 Date 对象中的年份（四位数字）。</td>
</tr>
<tr>
<td align="left">setUTCHours()</td>
<td align="left">根据世界时设置 Date 对象中的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="left">setUTCMilliseconds()</td>
<td align="left">根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。</td>
</tr>
<tr>
<td align="left">setUTCMinutes()</td>
<td align="left">根据世界时设置 Date 对象中的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left">setUTCMonth()</td>
<td align="left">根据世界时设置 Date 对象中的月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="left">setUTCSeconds()</td>
<td align="left">setUTCSeconds() 方法用于根据世界时 (UTC) 设置指定时间的秒字段。</td>
</tr>
<tr>
<td align="left">setYear()</td>
<td align="left">已废弃。请使用 setFullYear() 方法代替。</td>
</tr>
<tr>
<td align="left">toDateString()</td>
<td align="left">把 Date 对象的日期部分转换为字符串。</td>
</tr>
<tr>
<td align="left">toGMTString()</td>
<td align="left">已废弃。请使用 toUTCString() 方法代替。</td>
</tr>
<tr>
<td align="left">toISOString()</td>
<td align="left">使用 ISO 标准返回字符串的日期格式。</td>
</tr>
<tr>
<td align="left">toJSON()</td>
<td align="left">以 JSON 数据格式返回日期字符串。</td>
</tr>
<tr>
<td align="left">toLocaleDateString()</td>
<td align="left">根据本地时间格式，把 Date 对象的日期部分转换为字符串。</td>
</tr>
<tr>
<td align="left">toLocaleTimeString()</td>
<td align="left">根据本地时间格式，把 Date 对象的时间部分转换为字符串。</td>
</tr>
<tr>
<td align="left">toLocaleString()</td>
<td align="left">据本地时间格式，把 Date 对象转换为字符串。</td>
</tr>
<tr>
<td align="left">toString()</td>
<td align="left">把 Date 对象转换为字符串。</td>
</tr>
<tr>
<td align="left">toTimeString()</td>
<td align="left">把 Date 对象的时间部分转换为字符串。</td>
</tr>
<tr>
<td align="left">toUTCString()</td>
<td align="left">根据世界时，把 Date 对象转换为字符串。实例：<code>var today = new Date(); var UTCstring = today.toUTCString();</code></td>
</tr>
<tr>
<td align="left">UTC()</td>
<td align="left">根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。</td>
</tr>
<tr>
<td align="left">valueOf()</td>
<td align="left">返回 Date 对象的原始值。</td>
</tr>
<tr>
<td align="left"><strong>now()</strong></td>
<td align="left"><strong>返回当前时间戳。</strong>可以用于测试代码的执行性能。从性能上来讲Date.now()要快于new.Date().getTime()</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">var start = Date.now();<br>       执行语句…<br>var end = Date.now();<br>console.log(“共花费” + (end - start) + “毫秒”);</td>
</tr>
</tbody></table>
<h4 id="十、Math对象（内建对象）"><a href="#十、Math对象（内建对象）" class="headerlink" title="十、Math对象（内建对象）"></a>十、Math对象（内建对象）</h4><p>和其他对象不同，它不是一个构造函数。它属于一个工具类，不用创建对象，它里面封装了数学运算相关的属性和方法</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">abs(x)</td>
<td align="left">返回 x 的绝对值。</td>
</tr>
<tr>
<td align="left"><strong>ceil(x)</strong></td>
<td align="left"><strong>对数进行上舍入。</strong></td>
</tr>
<tr>
<td align="left">sin(x)</td>
<td align="left">返回数的正弦。</td>
</tr>
<tr>
<td align="left">cos(x)</td>
<td align="left">返回数的余弦。</td>
</tr>
<tr>
<td align="left">tan(x)</td>
<td align="left">返回角的正切。</td>
</tr>
<tr>
<td align="left">exp(x)</td>
<td align="left">返回 Ex 的指数。</td>
</tr>
<tr>
<td align="left"><strong>floor(x)</strong></td>
<td align="left"><strong>对 x 进行下舍入。</strong></td>
</tr>
<tr>
<td align="left">log(x)</td>
<td align="left">返回数的自然对数（底为e）。</td>
</tr>
<tr>
<td align="left">max(x,y,z,…,n)</td>
<td align="left">返回 x,y,z,…,n 中的最高值。</td>
</tr>
<tr>
<td align="left">min(x,y,z,…,n)</td>
<td align="left">返回 x,y,z,…,n中的最低值。</td>
</tr>
<tr>
<td align="left">pow(x,y）</td>
<td align="left">返回 x 的 y 次幂。</td>
</tr>
<tr>
<td align="left"><strong>random()</strong></td>
<td align="left"><strong>返回 0 ~ 1 之间的随机数。</strong></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">取[Min,Max]区间的随机数，<code>Min+Math.floor(Math.random()*(Max-Min))</code></td>
</tr>
<tr>
<td align="left"><strong>round(x)</strong></td>
<td align="left"><strong>四舍五入。</strong></td>
</tr>
<tr>
<td align="left">sqrt(x)</td>
<td align="left">返回数的平方根。</td>
</tr>
</tbody></table>
<h4 id="十一、String对象（内建对象）"><a href="#十一、String对象（内建对象）" class="headerlink" title="十一、String对象（内建对象）"></a>十一、String对象（内建对象）</h4><p>在底层字符串是以字符数组的形式保存的。使用length可以获取字符串的长度。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>charAt()</strong></td>
<td align="left"><strong>返回指定索引位置的字符</strong></td>
</tr>
<tr>
<td align="left"><strong>charCodeAt()</strong></td>
<td align="left"><strong>返回指定索引位置字符的 Unicode 值</strong></td>
</tr>
<tr>
<td align="left"><strong>concat()</strong></td>
<td align="left"><strong>连接两个或多个字符串，返回连接后的字符串</strong> 。作用和+号一样</td>
</tr>
<tr>
<td align="left">fromCharCode()</td>
<td align="left">将 Unicode 转换为字符串。但是这个属于String构造函数的方法                                   <code>var str = String.fromCharCode(Unicode值);</code></td>
</tr>
<tr>
<td align="left"><strong>indexOf()</strong></td>
<td align="left"><strong>返回字符串中检索指定字符第一次出现的位置，如果找不到指定字符，则返回-1</strong></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>str.indexOf(searchvalue,start)</code>start规定在字符串中开始检索的位置。</td>
</tr>
<tr>
<td align="left"><strong>includes()</strong></td>
<td align="left"><strong>用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。用法同indexOf()</strong></td>
</tr>
<tr>
<td align="left"><strong>lastIndexOf()</strong></td>
<td align="left"><strong>返回字符串中检索指定字符最后一次出现的位置</strong></td>
</tr>
<tr>
<td align="left">localeCompare()</td>
<td align="left">用本地特定的顺序来比较两个字符串</td>
</tr>
<tr>
<td align="left"><strong>match()</strong></td>
<td align="left"><strong>找到一个或多个正则表达式的匹配</strong>。即根据正则表达式，从一个字符串中将符合条件的内容提取出来并以数组的形式返回，即使只查询到一个结果。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">默认情况下，match只会找到第一个符合要求的内容，找到之后就会停止检索。可以人为设置正则表达式的匹配模式为全局匹配模式g。可以为一个正则表达式设置多个匹配模式，且无所谓顺序。</td>
</tr>
<tr>
<td align="left"><strong>replace()</strong></td>
<td align="left"><strong>替换与正则表达式匹配的子串</strong></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>str.replace(searchvalue,newvalue)</code>。searchvalue为被替换掉的内容，也可以接受一个正则表达式作为参数。newvalue为替换内容，可以将其置空串“”，此时用于删除searchvalue。默认只替换第一个，如要全局替换，需要设置匹配模式为全局匹配。</td>
</tr>
<tr>
<td align="left"><strong>search()</strong></td>
<td align="left"><strong>检索与正则表达式相匹配的值</strong>。返回字符串中检索指定字符第一次出现的位置，如果找不到指定字符，则返回-1。但与indexOf()不同的是，它可以接收正则表达式作为参数，然后根据正则表达式来检索字符串。search()即使设置全局匹配也只会查找出指定字符第一次出现的位置。</td>
</tr>
<tr>
<td align="left"><strong>slice()</strong></td>
<td align="left"><strong>提取字符串的片断，并在新的字符串中返回被提取的部分</strong>。不会影响原字符串</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>array.slice(start, end)</code> 返回一个新的数组，包含下标∈[start,end)的元素。start如果是负数，那么它规定从数组尾部开始算起的位置，end如果数是负数，那么它规定的是从数组尾部开始算起的元素。</td>
</tr>
<tr>
<td align="left"><strong>split()</strong></td>
<td align="left"><strong>把字符串分割为子字符串数组，返回的是该字符串数组</strong>。需要一个字符串作为参数，将会根据该字符串去拆分数组。用法与join()相反</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">split()方法可以搭配正则表达式灵活拆解字符串。如 <code>str.split(/[A-z]/)</code>根据任意字母对str进行拆解。默认全局拆分</td>
</tr>
<tr>
<td align="left"><strong>join()</strong></td>
<td align="left"><strong>把数组的所有元素放入一个字符串，括号内可以填写连接符。</strong>与split()相反</td>
</tr>
<tr>
<td align="left"><strong>substr()</strong></td>
<td align="left"><strong>从起始索引号提取字符串中指定数目的字符</strong></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>str.substr(start,length)</code>返回一个下标从start开始长度为length的数组，start用法同slice()中的start，length不为负</td>
</tr>
<tr>
<td align="left"><strong>substring()</strong></td>
<td align="left"><strong>提取字符串中两个指定的索引号之间的字符</strong></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>str.substring(from, to)</code>返回一个新的数组，包含下标∈[from,to)的元素。from和end都不得为负。如果传递了一个负值，则默认使用0，而且它自动调整参数的位置，如果第二个参数小于第一个，则自动交换。</td>
</tr>
<tr>
<td align="left">toLowerCase()</td>
<td align="left">把字符串转换为小写</td>
</tr>
<tr>
<td align="left">toString()</td>
<td align="left">返回字符串对象值</td>
</tr>
<tr>
<td align="left">toUpperCase()</td>
<td align="left">把字符串转换为大写</td>
</tr>
<tr>
<td align="left"><strong>trim()</strong></td>
<td align="left"><strong>移除字符串首尾空白</strong></td>
</tr>
<tr>
<td align="left">valueOf()</td>
<td align="left">返回某个字符串对象的原始值</td>
</tr>
</tbody></table>
<p><strong>正则表达式</strong></p>
<p>正则表达式用于定义一些字符串的规则，计算机可以根据正则表达式，来检查一个字符串是否符合规则，然后将字符串中符合规则的内容提取出来。正则表达式严格区分大小写。</p>
<ol>
<li><p><u>创建正则表达式对象</u></p>
<p><code>var reg = new RegExp(&quot;正则表达式&quot;,&quot;匹配模式&quot;);</code>，使用typeof检查正则对象，会返回object。在构造函数中可以传递一个匹配模式作为第二个参数，可以是</p>
<p><strong>i：忽略大小写        g：全局匹配模式        m：多行匹配</strong></p>
<p>当然也可以使用字面量来创建正则表达式 <code>var reg = /正则表达式/ 匹配模式;</code></p>
<p>使用字面量方式创建更加简洁，使用构造函数创建更加灵活</p>
</li>
<li><p><u>匹配</u>：检查字符串是否符合正则表达式</p>
<p><code>var result = reg.test(str);</code>，test()是正则表达式的方法，用于检查字符串是否符合正则表达式，返回值是布尔值</p>
</li>
<li><p><u>捕获</u>：获取字符串中符合正则表达式规则的字符</p>
<p><code>var result = reg.exec(str)</code>，当前正则要和字符串匹配，如果不匹配捕获的结果或者没有捕获到则为null，如果捕获成功，则返回一个数组：</p>
<ul>
<li>数组中第一项：本次捕获到的内容</li>
<li>其余项：对应小分组本次单独捕获的内容</li>
<li>index：当前捕获内容在字符串中的起始索引</li>
<li>input：原始字符串</li>
<li>……</li>
</ul>
</li>
</ol>
<p>其中捕获的特点：</p>
<ul>
<li>懒惰性：只捕获一次，除非加上全局修饰符g</li>
<li>贪婪性：默认情况下，按照当前正则所匹配的最长结果来获取的</li>
</ul>
<p><strong>正则表达式模式</strong></p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[abc]</td>
<td align="left">方括号用于查找某个范围内的字符，如[abc]==a|b|c</td>
</tr>
<tr>
<td align="left">[a-z]</td>
<td align="left">查找方括号之间（包含两端）的任何字符。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">[a-z]表示任意小写字母；[A-Z]表示任意大写字母；[a-zA-Z]表示任意字母</td>
</tr>
<tr>
<td align="left">[0-9]</td>
<td align="left">查找任何从 0 至 9 的数字。</td>
</tr>
<tr>
<td align="left">[^]</td>
<td align="left">不在方括号内的任意字符</td>
</tr>
<tr>
<td align="left">(x|y)</td>
<td align="left">查找任何以 | 分隔的选项。</td>
</tr>
</tbody></table>
<p>元字符就是正则表达式中斜杠中间的内容</p>
<table>
<thead>
<tr>
<th align="left">特殊元字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.</td>
<td align="left">除换行符和其他Unicode行终止符之外的任意字符。</td>
</tr>
<tr>
<td align="left">\.</td>
<td align="left">表示真正的 . 字符，其中 \ 同样用作转义符。</td>
</tr>
<tr>
<td align="left">\\</td>
<td align="left">表示 \ 字符。</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">表示任意的字母、数字和下划线_，\w==[a-zA-Z0-9_]。</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">除了字母、数字、下划线， \W==[ ^a-zA-Z0-9_]。</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">表示数字。\d==[0-9]。</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">除了数字。\D==[ ^0-9]。</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">表示空格。</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">除了空格</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">匹配单词边界。如 /\bchild\b/，该正则表达式时检查一个字符串中是否含有单词child</td>
</tr>
<tr>
<td align="left">\B</td>
<td align="left">匹配非单词边界的位置。</td>
</tr>
<tr>
<td align="left">\uxxxx</td>
<td align="left">查找以十六进制数 xxxx 规定的 Unicode 字符。</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">匹配换页字符</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">匹配换行字符</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">匹配回车符字符</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">匹配制表字符</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">匹配垂直制表符</td>
</tr>
</tbody></table>
<p>量词: 量词只对前边的一个内容起作用。</p>
<table>
<thead>
<tr>
<th align="left">量词</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">{n}</td>
<td align="left">匹配出现 <em>n</em> 次的字符串。</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">匹配出现至少 <em>n</em> 次，但至多 <em>m</em> 次的字符串。</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">匹配出现至少 <em>n</em> 次的字符串。</td>
</tr>
<tr>
<td align="left">s+</td>
<td align="left">匹配任何包含至少一个 <em>s</em> 的字符串。相当于<em>s</em>{1,}。</td>
</tr>
<tr>
<td align="left">s*</td>
<td align="left">匹配任何包含零个或多个 <em>s</em> 的字符串。相当于<em>s</em>{0,}</td>
</tr>
<tr>
<td align="left">s?</td>
<td align="left">匹配任何包含零个或一个 <em>s</em> 的字符串。相当于<em>s</em>{0,1}</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">问号左边是非量词元字符：本身代表量词元字符，出现一到两次<br>问号左边是量词元字符：取消正则捕获的贪婪性<br>(?:)  只匹配不捕获<br>(?=)   正向预查（必须得包含什么）<br>(?!)    负向预查（必须不能有什么）</td>
</tr>
</tbody></table>
<p>锚字符：用于指定匹配位置</p>
<table>
<thead>
<tr>
<th>锚字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配字符串的开头，在多行检索中，匹配一行的开头。如<code>/^a/</code>表示以a为开头的字符串，注意区别于[^]</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结尾，在多行检索中，匹配一行的结尾。如<code>/a$/</code>表示以a为结尾的字符串。</td>
</tr>
<tr>
<td><strong>^  $</strong></td>
<td><strong>正则表达式中同时使用 ^ $ ，则要求字符串必须完全符合正则表达式</strong></td>
</tr>
</tbody></table>
<p>举例：</p>
<ul>
<li><u>手机号码的规则</u></li>
</ul>
<ol>
<li>以1开头</li>
<li>第二位3-9的任意数字</li>
<li>三位以后任意数字9个</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="string">"17826660629"</span>;</span><br><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/^1[3-9][0-9]&#123;9&#125;$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num+<span class="string">"是否为手机号："</span>+reg.test(num));</span><br></pre></td></tr></table></figure>

<ul>
<li><u>电子邮箱的规则</u></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如 </span><br><span class="line">	hello		   .nihao   	@	 	abc 				.com  				.cn</span><br><span class="line">任意字母下划线   .任意字母下划线	   @	任意字母数字	      .任意字母（<span class="number">2</span><span class="number">-5</span>位）    .任意字母（<span class="number">2</span><span class="number">-5</span>位）</span><br><span class="line">	\w&#123;<span class="number">3</span>,&#125;        (\.\w+)*		@    [a-zA-Z0<span class="number">-9</span>]+            (\.[a-zA-Z]&#123;<span class="number">2</span>,<span class="number">5</span>&#125;)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> email=<span class="string">"24589664852@qq.com"</span></span><br><span class="line"><span class="keyword">var</span> emailReg=<span class="regexp">/^\w&#123;3,&#125;(\.\w+)*@[a-zA-Z0-9]+(\.[a-zA-Z]&#123;2,5&#125;)&#123;1,2&#125;$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(email+<span class="string">"是否为电子邮箱："</span>+reg.test(email));</span><br></pre></td></tr></table></figure>

<p><strong>match 与 exec 的区别</strong></p>
<ul>
<li><p>设置全局修饰符g的情况下</p>
<ul>
<li>exec 每次执行只能捕获一个结果，如果想要捕获全，需要执行多次</li>
<li>match 执行一次就能把所有正则匹配的信息捕获到</li>
</ul>
</li>
<li><p>不设置g的情况下</p>
<p>都只能捕获到第一个匹配的结果，获取的结果一模一样</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">let</span> str = <span class="string">"eason2019eason2020eason2021"</span>;</span><br><span class="line">   <span class="keyword">let</span> reg = <span class="regexp">/\d+/g</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(reg.exec(str)); <span class="comment">//=&gt;["2019"...]</span></span><br><span class="line">   <span class="built_in">console</span>.log(reg.lastIndex); <span class="comment">//=&gt; 9 //=&gt;设置全局匹配修饰符g后，第一次匹配完，lastIndex会自己修改</span></span><br><span class="line">   <span class="built_in">console</span>.log(reg.exec(str)); <span class="comment">//=&gt;["2020"...]</span></span><br><span class="line">   <span class="built_in">console</span>.log(reg.lastIndex); <span class="comment">//=&gt; 18</span></span><br><span class="line">   <span class="built_in">console</span>.log(reg.exec(str)); <span class="comment">//=&gt;["2021"...]</span></span><br><span class="line">   <span class="built_in">console</span>.log(reg.lastIndex); <span class="comment">//=&gt; 27</span></span><br><span class="line"><span class="comment">//当全部捕获后，再次捕获的结果是null，但是lastIndex又回归了初始值零，再次捕获又从第一个开始了... </span></span><br><span class="line">   <span class="built_in">console</span>.log(reg.exec(str)); <span class="comment">//=&gt;null </span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(reg.lastIndex); <span class="comment">//=&gt;0</span></span><br><span class="line">   <span class="built_in">console</span>.log(reg.exec(str)); <span class="comment">//=&gt;["2019"...]</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"==================="</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> result=str.match(reg);</span><br><span class="line">   <span class="built_in">console</span>.log(result);		<span class="comment">// [ "2019", "2020", "2021" ]</span></span><br></pre></td></tr></table></figure>

<p><strong>正则表达式与replace的用法</strong></p>
<ul>
<li><p>在不使用正则的情况下</p>
<p>每一次执行 replace 只能替换一个，而且很多是不使用正则无法解决的</p>
</li>
<li><p>结合正则<code>str=str.replace(reg,newvalue)</code></p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"eason@2019|eason@2020"</span>;</span><br><span class="line"><span class="comment">//=&gt;把"eason"替换成"XU"</span></span><br><span class="line"><span class="comment">//1.不用正则，执行一次只能替换一个</span></span><br><span class="line">str = str.replace(<span class="string">"eason"</span>,<span class="string">"XU"</span>).replace(<span class="string">"eason"</span>,<span class="string">"XU"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);			<span class="comment">//XU@2019|XU@2020</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用正则会简单一点</span></span><br><span class="line">str = str.replace(<span class="regexp">/eason/g</span>,<span class="string">"XU"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);			<span class="comment">//XU@2019|XU@2020</span></span><br></pre></td></tr></table></figure>

<h4 id="包装类（仅作了解）"><a href="#包装类（仅作了解）" class="headerlink" title="包装类（仅作了解）"></a>包装类（仅作了解）</h4><p>JS提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象</p>
<ul>
<li><p>String()：可以将基本数据类型字符串转换为String对象 </p>
<p><code>var str = new String(&quot;hello&quot;);</code></p>
</li>
<li><p>Number()：可以将基本数据类型数字转换为Number对象 </p>
<p><code>var num = new Number(3);</code></p>
</li>
<li><p>Boolean()：可以将基本数据类型布尔值转换为Boolean对象 </p>
<p><code>var bool = new Boolean(true);</code></p>
</li>
</ul>
<p>但是实际应用中不会使用基本数据类型对象，因为如果使用会在做一些比较时可能会带来一些不可于其的结果。方法和属性只能添加给对象，不能添加给基本数据类型，当对一些基本数据类型的值去调用属性和方法时，如<code>str.toString()</code>，浏览器会临时使用包装类将其转换为对象，然后再调用对象的属性和方法，调用完之后，再将其转换为基本数据类型。</p>
<h4 id="十二、DOM（宿主对象）"><a href="#十二、DOM（宿主对象）" class="headerlink" title="十二、DOM（宿主对象）"></a>十二、DOM（宿主对象）</h4><p><strong>DOM（Document Object Model）文档对象模型</strong>，JS通过DOM来对HTML文档进行操作。</p>
<p>文档表示的就是整个HTML网页文档；对象表示将网页中的每一个部分都转换为一个对象；模型表示对象之间的关系，方便获取对象。</p>
<p>![](JavaScript基础（尚硅谷）\HTML DOM树.png)</p>
<p><strong>节点</strong></p>
<p>节点Node——构成HTML文档最基本的单元</p>
<p>常用的节点分为四类：</p>
<ul>
<li>文档节点（Document）：整个HTML文档 </li>
<li>元素节点（Element）：HTML文档中的HTML标签</li>
<li>属性节点（Attribute）：元素的属性</li>
<li>文本节点（Text）：HTML标签中的文本内容</li>
</ul>
<table>
<thead>
<tr>
<th>节点类型      /      节点属性</th>
<th>nodeName</th>
<th>nodeType</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody><tr>
<td>文档节点</td>
<td>#document</td>
<td>9</td>
<td>null</td>
</tr>
<tr>
<td>元素节点</td>
<td>标签名</td>
<td>1</td>
<td>null</td>
</tr>
<tr>
<td>属性节点</td>
<td>属性名</td>
<td>2</td>
<td>属性值</td>
</tr>
<tr>
<td>文本节点</td>
<td>#text</td>
<td>3</td>
<td>文本内容</td>
</tr>
</tbody></table>
<p><strong>文档节点</strong></p>
<p>浏览器已经提供了文档节点对象document，该对象是window属性，所以可以直接使用。</p>
<p>通过文档节点得到整个网页上的任意一个节点（或叫元素）<code>document.getElementById(&quot;元素id名&quot;);</code>；</p>
<p>使用<strong>innerHTML属性</strong><u>获取元素内部HTML代码</u>（也可以通过更改innerHTML属性来修改元素），innerHTML 属性设置或返回表格行的开始和结束标签之间的 HTML，对单标签没有意义。</p>
<p>使用<strong>innerText属性</strong>获取元素文本内容，同样对单标签没有意义</p>
<p><strong>事件</strong></p>
<p>事件就是用户和浏览器之间的交互行为，JavaScript与HTML之间的交互是通过事件来实现的。</p>
<p>常用事件                                                                                                                                                            <a href="https://www.runoob.com/jsref/dom-obj-event.html" target="_blank" rel="noopener">更多事件</a></p>
<table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">onchange</td>
<td align="left">HTML 元素改变</td>
</tr>
<tr>
<td align="left">onclick</td>
<td align="left">用户点击 HTML 元素</td>
</tr>
<tr>
<td align="left">onmouseover</td>
<td align="left">用户在一个HTML元素上移动鼠标</td>
</tr>
<tr>
<td align="left">onmouseout</td>
<td align="left">用户从一个HTML元素上移开鼠标</td>
</tr>
<tr>
<td align="left">onkeydown</td>
<td align="left">用户按下键盘按键。键盘事件一般绑定给可以获得焦点的对象，或者是document。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">对于onkeydown来说，如果一直按着键盘按键会连续触发</td>
</tr>
<tr>
<td align="left">onscroll</td>
<td align="left">用户滚动滚动条</td>
</tr>
<tr>
<td align="left">onload</td>
<td align="left">一张页面或一幅图像完成加载。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">浏览器在加载一个页面时，是自上而下加载的，逐行读取并执行。因此如果script标签在HTML的body标签的前面，代码执行时，页面并没有加载，无法获取DOM对象。因此为window绑定onload事件，可以使页面加载完毕之后再执行事件，而无需考虑script标签的位置问题。<br>window.onload=function{<br>           语句…<br>}</td>
</tr>
</tbody></table>
<img src="/2020/05/12/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/mouseover和mouseenter的区别.png" style="zoom: 50%;">

<p><strong>DOM查询</strong></p>
<p><strong>获取元素节点（通过document对象调节）</strong></p>
<ul>
<li>getElementById()：通过id属性获取 <u>一个</u> 元素节点对象</li>
<li>getElementsByTagName()：通过标签名获取 <u>一组</u> 元素节点对象。这个方法返回一个类数组对象，所有查询到的元素都会封装到对象中。即使查询到的元素只有一个，也会封装到数组中。</li>
<li>getElementsByName()：通过name属性获取 <u>一组</u> 元素节点对象</li>
</ul>
<p>获取元素节点属性</p>
<p>直接使用 <code>元素.属性名</code>，如<code>元素.value</code>， <code>元素.name</code>， <code>元素.value</code>…… class属性不能采用这种方式，读取class属性时，需要使用 <code>元素.className</code></p>
<p><strong>获取元素节点的子节点（通过具体的元素节点调用）</strong></p>
<ul>
<li>getElementsByTagName()：方法，返回当前节点的指定标签后代节点</li>
<li>childNodes：属性，表示当前节点的所有子节点（包括文本节点的所有子节点，DOM标签间的空白文本也会当成文本节点。在IE8及以下的浏览器中，不会将空白当作子节点）</li>
<li>children：属性，表示当前元素的所有子元素（注意与childNodes的区别，不会将DOM标签间的空白当作子元素）</li>
<li>firstChild：属性，表示当前节点的第一个子节点（包括DOM标签间的空白文本节点）</li>
<li>firstElementChild：属性，表示当前元素的第一个子元素（IE8及以下的浏览器不支持）</li>
<li>lastChild：属性，表示当前节点的最后一个子节点</li>
</ul>
<p><strong>获取元素节点的父节点和兄弟节点（通过具体的元素节点调用）</strong></p>
<ul>
<li>parentNode：属性，表示当前节点的父节点</li>
<li>previousSibling：属性，表示当前节点的前一个兄弟节点（可能获取空白文本节点）</li>
<li>previousElementSibling：属性，表示当前元素的前一个兄弟元素（IE8及以下的浏览器不支持）</li>
<li>nextSibling：属性，表示当前节点的后一个兄弟节点（可能获取空白文本节点）</li>
<li>nextElementSibling：属性，表示当前元素的后一个兄弟元素（IE8及以下的浏览器不支持）</li>
</ul>
<p><strong>DOM查询的剩余方法</strong></p>
<ul>
<li>document.body：HTML中的body标签</li>
<li>document.documentElement：HTML根标签</li>
<li>document.all：页面中所有的元素</li>
<li>document.getElementsByClassName()：根据元素的class属性值查询一组元素节点对象（IE8及以下的浏览器不支持）</li>
<li>document.querySelector()：需要一个选择器的字符串作为参数，可以根据一个CSS选择器来查找有一个元素节点对象。使用该方法只有返回第一个元素（IE8浏览器可以使用这个方法来替代）</li>
<li>document.querySelectorAll()：用法与document.querySelector()一致，但是会将所有负荷条件的元素封装到一个数组中返回（即使只有一项也是个集合）</li>
</ul>
<p><strong>DOM增删改</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><em>element</em>.createElement()</td>
<td>创建一个元素节点对象，并将创建好的对象作为返回值返回。需要元素名称作为参数</td>
</tr>
<tr>
<td><em>element</em>.createTextNode()</td>
<td>创建一个文本对象节点，并将创建好的对象作为返回值返回。需要文本内容作为参数</td>
</tr>
<tr>
<td><em>element</em>.appendChild()</td>
<td>为元素添加一个新的子元素。需要新的子元素作为参数</td>
</tr>
<tr>
<td><em>element</em>.insertBefore()</td>
<td>现有的子元素之前插入一个新的子元素。该方法由父元素调用</td>
</tr>
<tr>
<td></td>
<td><code>父节点.insertBefore(newnode,existingnode);</code>newnode表示要插入的节点，existingnode表示添加新节点前的子节点</td>
</tr>
<tr>
<td><em>element</em>.replaceChild()</td>
<td>替换一个子元素</td>
</tr>
<tr>
<td></td>
<td><code>父节点.replaceChild(newnode,oldnode);</code>newnode表示要插入的节点，oldnode表示要移除的节点</td>
</tr>
<tr>
<td><em>element</em>.removeChild()</td>
<td>删除一个子元素。以待删除的子节点作为参数</td>
</tr>
<tr>
<td></td>
<td><code>父节点.removeChild(待删子节点);</code>  相当于  <code>待删子节点.parentNode.removeChild(待删子节点)</code></td>
</tr>
</tbody></table>
<p><strong>DOM操作内联样式（行间样式）</strong></p>
<p>通过JS修改元素的样式：<code>element.style.样式名 = 样式值;</code>。注意，如果CSS样式名中含有 - ，这种名称在JS中是不合法的，需要将其修改为驼峰命名法，如CSS中 background-color 属性，需要修改为 backgroundColor。</p>
<p>通过style属性设置修改的样式都是内联样式，而内联样式是有较高优先级的，所以通过JS修改的样式往往会立即显示。但是如果在样式中设置了 !important ，则此时该样式会有最高的优先级，即使使用JS也不能对其样式进行覆盖，JS修改样式失效，所以尽量不要为样式添加 !important。</p>
<p>通过style属性设置和读取的都是内联样式，无法读取样式表（内部样式）中的样式。</p>
<p><strong>DOM操作class样式类</strong></p>
<p>操作的是当前元素的样式类，基于样式类的管理给予其不同的样式</p>
<p><code>element.className=&quot;样式类&quot;</code>：将之前的样式类名覆盖掉</p>
<p><code>element.className+=&quot;空格 样式类&quot;</code>：使用空格区分每个样式类，这样能做添加样式类而不会覆盖原有的</p>
<p><code>element.classList.add(&quot;样式类&quot;)</code>：向指定样式集合中新增一个样式类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">增加 class — element.classList.add("样式类")</span><br><span class="line">删除 class — element.classList.remove("样式类")</span><br><span class="line">切换 class — element.classist.toggle("样式类")</span><br><span class="line">判断 class — element.classist.contains("样式类")</span><br></pre></td></tr></table></figure>

<p><strong>DOM获取当前样式</strong></p>
<p>获取元素当前显示的样式：<code>element.currentStyle.样式名</code>，无所谓是行间样式、内部样式还是外部样式。如果当前元素没有设置样式，则返回默认值。<strong>（仅IE支持！！淦）</strong></p>
<p>在其他浏览器中可以使用  getComputedStyle()  这个方法来获取元素当前的样式。这个方法是window的方法，所以可以直接使用。该方法需要两个参数：1. 要获取样式的元素 2. 伪元素（可选，一般传null）。该方法会返回一个对象，对象中封装了当前元素对应的样式  <code>getComputedStyle(element,null).样式名</code>。如果获取的样式没有设置，则会获取真实的值而不是默认值，比如没有设置width，它不会获取auto，而是一个真实的长度。（IE8及以下版本不支持该方法）</p>
<p><strong>注意</strong>：通过currentStyle和getComputedStyle()读取到的样式都是只读的，不能修改，如果想要修改，必须通过style属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于上述两种方法兼容性差，则自定义一个函数在所有浏览器中获取指定元素的当前样式</span></span><br><span class="line"><span class="comment">// element 要获取样式的元素</span></span><br><span class="line"><span class="comment">// styleName 要获取的样式名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">element,styleName</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//如果对象中没有找到方法，会返回undefined</span></span><br><span class="line">    <span class="comment">//通过这种方法可以解决不同版本浏览器的兼容性问题</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.getComputedStyle)&#123;</span><br><span class="line">        <span class="keyword">return</span> getComputedSytle(element,<span class="literal">null</span>)[styleName];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element.currentStyle[styleName];</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他样式相关的属性</strong></p>
<table>
<thead>
<tr>
<th>属性（只读）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><em>element</em>.clientHeight</td>
<td>在页面上返回内容的可视高度（不包括边框，外边距或滚动条，返回值是整数值，不带px）</td>
</tr>
<tr>
<td><em>element</em>.clientWidth</td>
<td>在页面上返回内容的可视宽度（不包括边框，外边距或滚动条，返回值是整数值，不带px）</td>
</tr>
<tr>
<td><em>element</em>.clientTop</td>
<td></td>
</tr>
<tr>
<td><em>element</em>.clientLeft</td>
<td></td>
</tr>
<tr>
<td><strong><em>element</em>.offsetHeight</strong></td>
<td><strong>返回元素的高度，包括边框和填充，但不包括外边距</strong></td>
</tr>
<tr>
<td><strong><em>element</em>.offsetWidth</strong></td>
<td><strong>返回元素的宽度，包括边框和填充，但不包括外边距</strong></td>
</tr>
<tr>
<td><em>element</em>.offsetParent</td>
<td>返回元素的偏移容器，即获取离当前元素最近的开启了定位（`position:relative</td>
</tr>
<tr>
<td><strong><em>element</em>.offsetTop</strong></td>
<td><strong>返回当前元素相对其偏移容器的垂直偏移位置</strong></td>
</tr>
<tr>
<td><strong><em>element</em>.offsetLeft</strong></td>
<td><strong>返回当前元素相对其偏移容器的水平偏移位置</strong></td>
</tr>
<tr>
<td><em>element</em>.scrollHeight</td>
<td>返回整个元素的高度（包括带滚动条的隐蔽的地方）</td>
</tr>
<tr>
<td><em>element</em>.scrollWidth</td>
<td>返回元素的整个宽度（包括带滚动条的隐蔽的地方）</td>
</tr>
<tr>
<td><em>element</em>.scrollLeft</td>
<td>返回水平滚动条滚动的距离（可读写）</td>
</tr>
<tr>
<td><em>element</em>.scrollTop</td>
<td>返回垂直滚动条滚动的距离（可读写）</td>
</tr>
<tr>
<td></td>
<td>⭐13个盒子模型属性，只有这两个是 可读写 的属性<br>当满足 <code>element.scrollHeight - element.scrollTop == element.clientHeight;</code> 说明垂直滚动条滚动到底了；<br>同理，当满足 <code>element.scrollWidth - element.scrollLeft == element.clientWidth;</code> 说明水平滚动条滚动到底了；</td>
</tr>
</tbody></table>
<p><strong>事件对象 event</strong></p>
<p>当事件响应，浏览器都会将一个事件对象作为实参传递进响应函数。<u>事件对象是由事件本身产生的，和绑定函数没有关系。</u>在事件对象中封装了当前事件相关的一切信息，比如，鼠标的坐标，键盘哪个按键被按下，鼠标滚轮方向等。</p>
<p>每次触发事件，浏览器都会做如下处理：</p>
<ol>
<li>捕获当前操作的行为，通过创建鼠标事件类、键盘事件类等类的实例，得到事件对象event</li>
<li>通知所有绑定的方法（符合执行条件的）开始执行，并且把event当作实参传递给每个方法，所以在每个方法中得到的事件对象是同一个</li>
<li>……</li>
<li>之后重新触发这个事件行为，会重新获取本次操作的信息，用新的信息替换老的信息，然后重复上述操作</li>
</ol>
<p>但是在IE8中，响应函数被触发时，浏览不会传递事件对象，在IE8及以下版本的浏览器中，得将事件对象作为window对象的属性保存。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>触发事件的类型</td>
</tr>
<tr>
<td>target</td>
<td>事件源（操作的是哪个元素，哪个元素就是事件源）</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>event.clientX</td>
<td>返回当事件被触发时，鼠标指针在当前可见窗口的水平坐标。</td>
</tr>
<tr>
<td>event.clientY</td>
<td>返回当事件被触发时，鼠标指针在当前可见窗口的垂直坐标。</td>
</tr>
<tr>
<td>event.pageX</td>
<td>获取鼠标相对于当前页面的水平坐标（IE8及以下不支持）</td>
</tr>
<tr>
<td>event.pageY</td>
<td>获取鼠标相对于当前页面的垂直坐标（IE8及以下不支持）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>preventDefault()</td>
<td>用来阻止默认行为的方法。</td>
</tr>
<tr>
<td>stopPropagation()</td>
<td>阻止冒泡传播</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//举例：通过JS实现在div1中滑动鼠标，在div2上输出鼠标的相对位置</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">		div&#123;</span><br><span class="line"><span class="css">			<span class="selector-tag">width</span><span class="selector-pseudo">:500px</span>;</span></span><br><span class="line"><span class="css">			<span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">			<span class="selector-tag">margin</span><span class="selector-pseudo">:20px</span> <span class="selector-tag">auto</span>;</span></span><br><span class="line">			border: 1px solid grey;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-id">#div2</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="selector-tag">height</span><span class="selector-pseudo">:20px</span>;</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">let</span> div1=<span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</span></span><br><span class="line"><span class="javascript">		<span class="keyword">let</span> div2=<span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>);</span></span><br><span class="line">      </span><br><span class="line"><span class="actionscript">		div1.onmousemove=<span class="function"><span class="keyword">function</span><span class="params">(event)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//利用 || 或运算符的短路解决event事件对象在不同浏览器中的兼容性问题</span></span></span><br><span class="line"><span class="javascript">            event=event || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> mouseX=event.clientX-div1.offsetLeft;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> mouseY=event.clientY-div1.offsetTop;</span></span><br><span class="line">			</span><br><span class="line"><span class="actionscript">            div2.innerHTML=<span class="string">"X: "</span>+mouseX+<span class="string">"   Y: "</span>+mouseY;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>事件的冒泡</strong></p>
<p>所谓的冒泡指的是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发。在实际开发中，大部分事件的冒泡是有利的。如果不希望发生事件冒泡，可以通过事件对象来取消冒泡。 </p>
<p>可以将事件对象的 cancelBubble设置为true，即可取消冒泡 <code>event.cancelBubble=true;</code>或者使用<code>event.stopPropagation()</code>。</p>
<p><strong>事件的委派</strong></p>
<p>指将事件统一绑定给多个元素共同的祖先元素，这样当后代元素上的事件需要被触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件（简单理解：让众多下属分别做的任务，统一交给上司去做，解决了浪费资源和新员工入职后不明确工作任务的难题）。事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能。</p>
<p><strong>事件的绑定</strong></p>
<ul>
<li>使用 <code>元素.on事件行为=function(){}</code>形式绑定响应函数只能同时为一个元素的一个事件绑定一个响应函数，不能绑定多个，如果绑定了多个，则后面的响应函数会覆盖掉前面的。</li>
<li>使用 <code>元素.addEventListener(e, function, useCapture)</code> 的形式绑定事件就可以解决上述问题。其中 e 表示事件的字符串，不需要on，如此前的鼠标单击事件，在此种情况下，对应的 e为”click”；function表示回调函数，当事件触发时该函数会被调用；<u>useCapture表示是否在捕获阶段触发事件，为一个布尔值，一般为false。</u>使用此种方法可以同时为一个元素同时绑定多个响应函数，这样当事件被触发时，响应函数会按照函数的绑定顺序执行。（IE8及以下版本不支持此方法）</li>
<li>IE8及以下版本使用<code>attachEvent()</code>方法进行替代，但是与之不同的是，<code>attachEvent()</code>仅含两个参数，一个表示事件的字符串，需要on，另一个是回调函数，如<code>对象.attachEvent(&quot;onclick&quot;,function)</code>。另外，它的执行顺序与<code>attachEvent()</code>相反。</li>
</ul>
<p><strong>注意</strong>：</p>
<ol>
<li><code>attachEvent()</code>方法中的this是window，<code>addEventListener()</code>方法中的this是绑定事件对象。</li>
<li><u>对于使用addEventListener()方法绑定的事件，return false不能用于取消默认事件，得使用event.preventDefault()</u></li>
</ol>
<p><strong>事件绑定的补充</strong></p>
<ul>
<li><p><u>DOM0 事件绑定</u>：<code>元素.on事件行为=function(){}</code>    </p>
<ul>
<li><p>原理：是给当前元素对象的私有属性（onxxx）赋值，只是赋值的是一个函数，当事件行为触发，浏览器会帮我们将绑定的方法执行。</p>
</li>
<li><p>缺点</p>
<ul>
<li>但是只有拥有这个事件属性名才能用这种方法做事件绑定，<small>元素没有ontransitionend这个属性，所以无法基于这种方式监听transitionend事件</small>；</li>
<li>重复赋值，后赋值的函数会覆盖之前的函数</li>
</ul>
</li>
<li><p>如果想要将这个绑定事件移出，只需要 <code>元素.on事件行为=null</code></p>
</li>
</ul>
</li>
<li><p><u>DOM2 事件绑定</u>：<code>元素.addEventListener(&quot;事件行为&quot;,function(){},true|false)</code></p>
<ul>
<li><p>原理：利用浏览器的事件池机制完成的，addEventListener相当于向浏览器事件池中注入相应的事件和方法；基于原型链查找机制，找到 EventTarget.prototype 上的方法并执行</p>
</li>
<li><p>特点</p>
<ul>
<li>可以给当前元素绑定多个不同的方法，当事件行为触发，会通知对应的方法依据事件注入顺序执行</li>
<li>与DOM0不同，只要是浏览器支持的事件行为都可以基于这种方法进行监听绑定</li>
</ul>
</li>
<li><p>通过设置useCapture为true，可以控制事件在捕获阶段执行；默认或者useCapture=false情况下，事件都在目标阶段和冒泡阶段触发执行</p>
</li>
</ul>
</li>
<li><p>移除绑定</p>
<p>做事件绑定的时候，一般不会给其绑定匿名函数（后期无法移除）。一般绑定的是实名函数</p>
<p>  <code>元素.removeEventListener(&quot;事件行为&quot;,实名函数名,true|false)</code></p>
</li>
</ul>
<p><small>事件池机制：存在去重的机制，“同一个元素，同一个事件类型，在事件池中只能存储一遍这个方法，不能重复存储”</small></p>
<p><strong>window.onload 和 $(document).ready()的区别</strong></p>
<ul>
<li><p><code>$(document).ready()</code></p>
<p>采用的是DOM2事件绑定，监听的是DOMContentLoaded这个事件，所以只要DOM结构加载完成就会被触发执行，而且同一个页面中可以使用多次（绑定不同的方法，因为基于DOM2事件池绑定机制完成的）</p>
</li>
<li><p><code>window.onload</code></p>
<p>必须等待所有资源都加载完成才会被触发执行，采用DOM0事件绑定，同一个页面只能绑定一次（一个方法），想绑定多个也需要改为<code>window.addEventListener(&#39;load&#39;, function () {})</code>DOM2绑定方式</p>
</li>
</ul>
<p><strong>事件的传播</strong></p>
<p>关于事件的传播，网景公司和微软公司有不同的理解。</p>
<p>微软公司认为事件应该是<u>由内向外</u>传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就是说事件应该在冒泡阶段执行。</p>
<p>网景公司认为事件应该是<u>由外向内</u>传播，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后在向内传播给后代元素。</p>
<p>W3C综合了两个公司的方案，将事件传播分成了三个阶段</p>
<ol>
<li><p><u>捕获阶段</u>（IE8及以下版本的浏览器不存在捕获阶段）</p>
<p>在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件</p>
</li>
<li><p><u>目标阶段</u></p>
<p>事件捕获到目标元素，捕获结束开始在目标元素上触发事件</p>
</li>
<li><p><u>冒泡阶段</u></p>
<p>事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件</p>
</li>
</ol>
<p>如果希望在捕获阶段就触发事件，可以将addEventListener()方法的第三个参数设置为true，一般情况下，我们不会希望在捕获阶段触发事件，所以第三参数一般都是false。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 举例 拖拽效果--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>拖拽效果<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        div &#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>:<span class="selector-id">#4ec0ca</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">left</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">top</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-id">#div2</span>&#123;</span></span><br><span class="line">            margin: 20px 20px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#f95227</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 拖拽的流程</span></span><br><span class="line"><span class="comment">	1.当鼠标在被拖拽元素上按下时，开始拖拽 onmousedown</span></span><br><span class="line"><span class="comment">	2.当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove</span></span><br><span class="line"><span class="comment">	3.当鼠标松开时，被拖拽元素固定在当前位置 onmouseup</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//将拖拽封装成函数</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">drag</span><span class="params">(obj)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            obj.onmousedown=<span class="function"><span class="keyword">function</span><span class="params">(event)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">//求出鼠标按下时，鼠标在div1中的相对位置</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> mouseX=event.pageX-obj.offsetLeft;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> mouseY=event.pageY-obj.offsetTop;</span></span><br><span class="line"><span class="actionscript">				<span class="comment">//为document绑定鼠标抬起事件</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.onmousemove=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    event=event||<span class="built_in">window</span>.event;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">                    <span class="keyword">var</span> divX=event.pageX-mouseX;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">var</span> divY=event.pageY-mouseY;</span></span><br><span class="line">                    </span><br><span class="line"><span class="actionscript">                    obj.style.left=divX+<span class="string">"px"</span>;</span></span><br><span class="line"><span class="actionscript">                    obj.style.top=divY+<span class="string">"px"</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="actionscript">				<span class="comment">//为document绑定鼠标抬起事件</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.onmouseup=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.onmousemove=<span class="literal">null</span>;</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">//为了不空耗事件造成误判，在执行完之后将其置空</span></span></span><br><span class="line"><span class="actionscript">                    <span class="comment">//从而取消该事件</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.onmouseup=<span class="literal">null</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="actionscript">                <span class="comment">//当执行拖拽网页中的内容时，浏览器会默认去搜寻引擎中搜索内容</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">//如按下 CTRL+A 进行全选，拖拽目标元素会影响网页中的其他元素</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">//从而导致拖拽异常，这个是浏览器的默认行为</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">//如果不希望这种情况发生，可以通过 return false 取消浏览器的默认行为</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">//（当然这种方式IE8不负众望，依旧不支持）</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> div1=<span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> div2=<span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>);</span></span><br><span class="line">        </span><br><span class="line">        drag(div1);</span><br><span class="line">        drag(div2);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 举例 鼠标滚轮事件--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>鼠标滚轮事件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#div1</span>&#123;</span></span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            margin: 100px auto;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#4ec0ca</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> div1=<span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</span></span><br><span class="line"><span class="actionscript">                div1.addEventListener(<span class="string">"wheel"</span>,<span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">//deltaY属性在向下滚动时返回正值，向上滚动时返回负值，否则为0。</span></span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// 注意：此属性是只读的。</span></span></span><br><span class="line">                    if(event.deltaY&gt;0)&#123;</span><br><span class="line"><span class="actionscript">                        div1.style.height=div1.clientHeight<span class="number">-10</span>+<span class="string">"px"</span>;</span></span><br><span class="line"><span class="actionscript">                        div1.style.width=div1.clientWidth<span class="number">-10</span>+<span class="string">"px"</span>;</span></span><br><span class="line"><span class="actionscript">                    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">                        div1.style.height=div1.clientHeight+<span class="number">10</span>+<span class="string">"px"</span>;</span></span><br><span class="line"><span class="actionscript">                        div1.style.width=div1.clientWidth+<span class="number">10</span>+<span class="string">"px"</span>;</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(div1.style.width)&lt;=<span class="number">50</span>)&#123;</span></span><br><span class="line"><span class="actionscript">                        div1.style.width=<span class="string">"50px"</span>;</span></span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(div1.style.height)&lt;=<span class="number">50</span>)&#123;</span></span><br><span class="line"><span class="actionscript">                        div1.style.height=<span class="string">"50px"</span>;</span></span><br><span class="line">                    &#125;</span><br><span class="line"><span class="actionscript">                    <span class="comment">//对于使用addEventListener()方法绑定的事件，</span></span></span><br><span class="line"><span class="actionscript">                    <span class="comment">//return false不能用于取消默认事件</span></span></span><br><span class="line"><span class="actionscript">                    <span class="comment">//得使用event.preventDefault()</span></span></span><br><span class="line">                    event.preventDefault();</span><br><span class="line"><span class="actionscript">                &#125;,<span class="literal">false</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"height: 2000px;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>键盘事件</strong></p>
<p>说明：在文本框中输入内容，属于onkeydown的默认行为。如果在onkeydown中使用return false取消了默认行为，则输入的内容，不会出现在文本框中。可以依据此类型规定文本框中什么可以输入，什么不可以。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规定文本框中不得输入数字</span></span><br><span class="line"><span class="keyword">if</span>(event.keyCode&gt;=<span class="number">48</span> &amp;&amp; event.keyCode&lt;=<span class="number">57</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>key</td>
<td>按键标识符是表示键盘按钮的字符串，该属性的返回值可以是：单个字母 (如 “a”, “W”, “4”, “+” 或 “$”)、多个字母 (如 “F1”, “Enter”, “HOME” 或 “CAPS LOCK”)提示： 如果你想查看是否按下了 “ALT”, “CTRL”, “META” 或 “SHIFT” 键，可使用 altKey, ctrlKey, metaKey 或 shiftKey 属性。</td>
</tr>
<tr>
<td>keyCode</td>
<td>该属性包含键盘中对应键位的键值（已被弃用）</td>
</tr>
<tr>
<td>charCode</td>
<td>该属性包含键盘中对应键位的 Unicode 编码，仅 DOM 支持</td>
</tr>
<tr>
<td>target</td>
<td>发生事件的节点（包含元素），仅 DOM 支持</td>
</tr>
<tr>
<td>srcElement</td>
<td>发生事件的元素，仅 IE 支持</td>
</tr>
<tr>
<td>shiftKey</td>
<td>是否按下 Shift 键，如果按下返回 true，否则为false</td>
</tr>
<tr>
<td>ctrlKey</td>
<td>是否按下 Ctrl 键，如果按下返回 true，否则为false</td>
</tr>
<tr>
<td>altKey</td>
<td>是否按下 Alt 键，如果按下返回 true，否则为false</td>
</tr>
<tr>
<td>metaKey</td>
<td>是否按下 Mtea 键，如果按下返回 true，否则为false，仅 DOM 支持</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>键位</th>
<th>码值</th>
</tr>
</thead>
<tbody><tr>
<td>0~9（数字键）</td>
<td>48~57</td>
</tr>
<tr>
<td>Backspace（退格键）</td>
<td>8</td>
</tr>
<tr>
<td>Enter（回车键）</td>
<td>13</td>
</tr>
<tr>
<td>Left arrow（左箭头键）</td>
<td>37</td>
</tr>
<tr>
<td>Right arrow（右箭头键）</td>
<td>39</td>
</tr>
</tbody></table>
<p>​     </p>
<h4 id="十三、BOM（宿主对象）"><a href="#十三、BOM（宿主对象）" class="headerlink" title="十三、BOM（宿主对象）"></a>十三、BOM（宿主对象）</h4><p><strong>BOM（Browser Object Model）浏览器对象模型</strong>，JS通过BOM来操作浏览器。BOM提供了一组对象，用于完成对浏览器的操作</p>
<p>BOM对象：</p>
<ol>
<li><p>Window</p>
<p>表示整个浏览器的窗口，同时window也是网页中的全局对象</p>
</li>
<li><p>Navigator</p>
<p>表示当前浏览器的当前信息，通过该对象可以用来识别不同的浏览器</p>
</li>
<li><p>Location</p>
<p>表示当前浏览器的地址信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面</p>
</li>
<li><p>History</p>
<p>表示浏览器的历史记录，可以通过该对象来操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或者向后翻页，而且该操作只能在当次访问时有效</p>
</li>
<li><p>Screen</p>
<p>表示用户的屏幕信息，通过该对象可以获取到用户的显示器的相关信息</p>
</li>
</ol>
<p>这些BOM对象在浏览器中都是作为window对象的属性进行保存，可以通过window对象来使用，也可以直接使用。</p>
<p><strong>Window对象</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>localStorage</td>
<td>localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除。localStorage 属性是只读的，返回值是一个存储对象。</td>
</tr>
<tr>
<td></td>
<td>保存数据语法：<code>localStorage.setItem(&quot;key&quot;,&quot;value&quot;);</code>（键值存储模式，其中值类型限定为String类型）<br>读取数据语法：<code>var lastInfo=localStorage.getItem(&quot;key&quot;);</code><br>删除数据语法：<code>localStorage.removeItem(&quot;key&quot;)</code></td>
</tr>
</tbody></table>
<p><strong>Navigator对象</strong></p>
<p>表示当前浏览器的当前信息，通过该对象可以用来识别不同的浏览器。由于历史原因，Navigator中的大部分属性都不能帮助我们识别浏览器了。一般只能使用userAgent来判断浏览器的信息。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">appCodeName</td>
<td align="left">返回浏览器的代码名</td>
</tr>
<tr>
<td align="left">appName</td>
<td align="left">返回浏览器的名称</td>
</tr>
<tr>
<td align="left">appVersion</td>
<td align="left">返回浏览器的平台和版本信息</td>
</tr>
<tr>
<td align="left">cookieEnabled</td>
<td align="left">返回指明浏览器中是否启用 cookie 的布尔值</td>
</tr>
<tr>
<td align="left">platform</td>
<td align="left">返回运行浏览器的操作系统平台</td>
</tr>
<tr>
<td align="left"><strong>userAgent</strong></td>
<td align="left"><strong>返回由客户机发送服务器的user-agent 头部的值</strong>，可以通过此属性判断浏览器版本</td>
</tr>
</tbody></table>
<p><strong>浏览器版本</strong></p>
<ul>
<li><p>Chrome/Edge：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (Linux; Android <span class="number">6.0</span>; Nexus <span class="number">5</span> Build/MRA58N) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">81.0</span><span class="number">.4044</span><span class="number">.138</span> Mobile Safari/<span class="number">537.36</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Edge</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">81.0</span><span class="number">.4044</span><span class="number">.138</span> Safari/<span class="number">537.36</span> Edg/<span class="number">81.0</span><span class="number">.416</span><span class="number">.72</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Firefox：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64; rv:<span class="number">76.0</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">76.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>IE11</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; WOW64; Trident/<span class="number">7.0</span>; .NET4<span class="number">.0</span>C; .NET4<span class="number">.0</span>E; .NET CLR <span class="number">2.0</span><span class="number">.50727</span>; .NET CLR <span class="number">3.0</span><span class="number">.30729</span>; .NET CLR <span class="number">3.5</span><span class="number">.30729</span>; rv:<span class="number">11.0</span>) like Gecko</span><br></pre></td></tr></table></figure>
</li>
<li><p>IE10</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (compatible; MSIE <span class="number">10.0</span>; Windows NT <span class="number">10.0</span>; WOW64; Trident/<span class="number">7.0</span>; .NET4<span class="number">.0</span>C; .NET4<span class="number">.0</span>E; .NET CLR <span class="number">2.0</span><span class="number">.50727</span>; .NET CLR <span class="number">3.0</span><span class="number">.30729</span>; .NET CLR <span class="number">3.5</span><span class="number">.30729</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其中，在IE11中已经将微软和IE相关的标识都去除了，所以无法通过userAgent这个属性来识别一个浏览器是否是IE11。如果通过userAgent不能判断，还可以通过一些浏览器中持有的对象，来判断浏览器的信息，比如Active。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用userAgent及其他浏览器属性判断当前浏览器的版本  </span></span><br><span class="line">	<span class="keyword">var</span> ua=navigator.userAgent;</span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/firefox/i</span>.test(ua))&#123;</span><br><span class="line">        alert(<span class="string">"FireFox"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="regexp">/Chrome/i</span>.test(ua) &amp;&amp; !<span class="regexp">/Edg/i</span>.test(ua))&#123;</span><br><span class="line">        alert(<span class="string">"Chrome"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="regexp">/Edg/i</span>.test(ua))&#123;</span><br><span class="line">        alert(<span class="string">"Edge"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"ActiveXObject"</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">        alert(<span class="string">"IE"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>History对象</strong></p>
<p>表示浏览器的历史记录，可以通过该对象来操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或者向后翻页，而且该操作只能在当次访问时有效</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">length</td>
<td align="left">返回历史列表中的网址数</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">back()</td>
<td align="left">加载 history 列表中的前一个 URL，作用和浏览器的回退按钮一样</td>
</tr>
<tr>
<td align="left">forward()</td>
<td align="left">加载 history 列表中的下一个 URL，作用和浏览器的前进按钮一样</td>
</tr>
<tr>
<td align="left">go()</td>
<td align="left">加载 history 列表中的某个指定页面，</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">它需要一个整数数值作为参数<br>1. 表示向前跳转一个页面<br>2. 表示向前跳转两个页面<br>-1. 表示向后跳转一个页面<br>-2. 表示向后跳转两个页面 ……</td>
</tr>
</tbody></table>
<p><strong>Location对象</strong></p>
<p>表示当前浏览器的地址信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面。如果直接打印location，则可以获取地址栏的信息（当前页面的完整路径）；如果直接向location修改为一个完整的路径，或者相对路径，则页面自动跳转到该路径，并且会生成相应的历史记录。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hash</td>
<td align="left">返回一个URL的锚部分</td>
</tr>
<tr>
<td align="left">host</td>
<td align="left">返回一个URL的主机名和端口</td>
</tr>
<tr>
<td align="left">hostname</td>
<td align="left">返回URL的主机名</td>
</tr>
<tr>
<td align="left">href</td>
<td align="left">返回完整的URL</td>
</tr>
<tr>
<td align="left">pathname</td>
<td align="left">返回的URL路径名。</td>
</tr>
<tr>
<td align="left">port</td>
<td align="left">返回一个URL服务器使用的端口号</td>
</tr>
<tr>
<td align="left">protocol</td>
<td align="left">返回一个URL协议</td>
</tr>
<tr>
<td align="left">search</td>
<td align="left">返回一个URL的查询部分</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">assign()</td>
<td align="left">载入一个新的文档。即用来跳转到其他页面，作用和直接修改location一样</td>
</tr>
<tr>
<td align="left">reload()</td>
<td align="left">重新载入当前文档。即刷新</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>location.reload(forceGet)</code>。forceGet可选。如果把该方法的参数设置为 true，那么无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下载该文档，即强制刷新。</td>
</tr>
<tr>
<td align="left">replace()</td>
<td align="left">用新的文档替换当前文档。参数为新文档的完整的路径或者相对路径。与直接修改location和调用assign()方法不同，它不会生成历史记录</td>
</tr>
</tbody></table>
<h4 id="十四、定时器简介"><a href="#十四、定时器简介" class="headerlink" title="十四、定时器简介"></a>十四、定时器简介</h4><p>JS程序执行速度非常快，如果希望一段程序，可以每间隔一段时间执行一次，可以使用定时调用</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>setInterval()</td>
<td><strong>定时调用</strong>。按照指定的周期（以毫秒计）来调用函数或计算表达式，如果不定义取消，则无限执行下去。返回一个Number类型的数据，这个数字用作定时器的唯一标识</td>
</tr>
<tr>
<td></td>
<td><code>setInterval(function, milliseconds);</code></td>
</tr>
<tr>
<td>setTimeout()</td>
<td><strong>延时调用</strong>。在指定的毫秒数后调用函数或计算表达式，且只执行一次。</td>
</tr>
<tr>
<td></td>
<td>延时调用和定时调用实际上是可以互相替代的，在开发中可以根据需求自行选择</td>
</tr>
<tr>
<td>clearInterval()</td>
<td>取消由 setInterval() 设置的 timeout。方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器。clearInterval()可以接受任意参数，如果参数是一个有效的定时器标识，则停止对应的定时器；如果参数不是有效的标识，如null、undefined，则什么也不做</td>
</tr>
<tr>
<td>clearTimeout()</td>
<td>取消由 setTimeout() 方法设置的 timeout。</td>
</tr>
</tbody></table>
<p><strong>轮播图练习</strong></p>
<h4 id="十五、类的操作"><a href="#十五、类的操作" class="headerlink" title="十五、类的操作"></a>十五、类的操作</h4><p>通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面，这种执行性能是比较差的。并且，当需要修改的样式个数较多时，不方便操作。</p>
<p>我们可以通过修改元素的class属性来间接修改样式（这个类指的是HTML中的类，与Java中类的概念要区别开）。这样一来，只需要人为修改一次，就可以同时修改多个样式，并且这种方式，可以使表现（CSS）和行为（JavaScript）进一步分离。并且可以通过<code>div1.className +=&quot; div2&quot;;</code>的方式，使用多个类控制（注意空格）。</p>
<p>但是使用<code>div1.className +=&quot; div2&quot;;</code>这种多类控制的方法容易形成 div2类名的多次添加，如 <code>&lt;div class=&quot;div1 div2 div2 div2&quot;&gt;</code>，形成冗余。为了防止这种现象出现，使用正则表达式判断class属性中是否已经含有了 div2</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>类的操作<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.div1</span>&#123;</span></span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#4ec0ca</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin</span><span class="selector-pseudo">:200px</span> <span class="selector-tag">auto</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.div2</span>&#123;</span></span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#f95227</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin</span><span class="selector-pseudo">:100px</span> <span class="selector-tag">auto</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> btn1=<span class="built_in">document</span>.getElementById(<span class="string">"btn1"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> btn2=<span class="built_in">document</span>.getElementById(<span class="string">"btn2"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> btn3=<span class="built_in">document</span>.getElementById(<span class="string">"btn3"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> div1=<span class="built_in">document</span>.getElementsByClassName(<span class="string">"div1"</span>)[<span class="number">0</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            btn1.onclick=<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                addClass(div1,<span class="string">"div2"</span>);</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            btn2.onclick=<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                removeClass(div1,<span class="string">"div2"</span>);</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            btn3.onclick=<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                toggleClass(div1,<span class="string">"div2"</span>);</span></span><br><span class="line">            &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="actionscript">            <span class="comment">//添加class属性</span></span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">addClass</span><span class="params">(obj,cn)</span></span>&#123;</span></span><br><span class="line">                if (!hasClass(obj,cn))&#123;</span><br><span class="line"><span class="actionscript">                    obj.className+=<span class="string">" "</span>+cn;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">//判断是否已有class属性</span></span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">hasClass</span><span class="params">(obj,cn)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\b"</span>+cn+<span class="string">"\\b"</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> reg.test(obj.className);</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">//删除class属性</span></span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">removeClass</span><span class="params">(obj,cn)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\b"</span>+cn+<span class="string">"\\b"</span>);</span></span><br><span class="line"><span class="actionscript">                obj.className=obj.className.replace(reg,<span class="string">""</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">//切换class属性</span></span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">toggleClass</span><span class="params">(obj,cn)</span></span>&#123;</span></span><br><span class="line">                if (!hasClass(obj,cn))&#123;</span><br><span class="line">                    addClass(obj,cn);</span><br><span class="line"><span class="actionscript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">                    removeClass(obj,cn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn1"</span>&gt;</span>点击我就变<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn2"</span>&gt;</span>点击我就变回来<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn3"</span>&gt;</span>变来变去<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>二级菜单练习</strong></p>
<h4 id="十六、JSON"><a href="#十六、JSON" class="headerlink" title="十六、JSON"></a>十六、JSON</h4><p>JS中的对象只有JS自己可识别，其他的语言无法识别。<strong>JSON（Javascript Object Notation）JS对象表示法</strong>，就是一个特殊格式的字符串，这个字符串可以被任意的语言识别，并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互。JSON和JS对象的格式一致，<u>只是JSON字符串中的属性名必须加双引号</u>，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objson = <span class="string">'&#123;"name":"Eason","age":18,"gender":"male"&#125;'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>JSON中允许的值</strong></p>
<ol>
<li>字符串</li>
<li>数值</li>
<li>布尔值</li>
<li>null</li>
<li>（普通）对象</li>
<li>数组</li>
</ol>
<p><strong>JSON字符串分类</strong></p>
<ul>
<li>对象 {}</li>
<li>数组 []</li>
</ul>
<p>JS提供了一个工具类，叫JSON，这个对象可以帮助将JSON字符串转换为JS对象，也可以将一个JS对象转换为JSON字符串。</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">JSON.parse()</td>
<td align="left">用于将一个 JSON 字符串转换为 JavaScript 对象并返回。</td>
</tr>
<tr>
<td align="left">JSON.stringify()</td>
<td align="left">用于将 JavaScript 对象（数组）转换为 JSON 字符串。</td>
</tr>
</tbody></table>
<h4 id="十七、三类输出方式"><a href="#十七、三类输出方式" class="headerlink" title="十七、三类输出方式"></a>十七、三类输出方式</h4><p><strong>console：控制在浏览器控制台输出</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>console.log</td>
<td>输出任意数据类型的数据，控制台展示的也是对应的数据类型</td>
</tr>
<tr>
<td>consoel.dir</td>
<td>输出一个对象或者一个值的详细信息<br>与console.log 不同的是，console.log可以一次性输出多个值，而console.dir不行</td>
</tr>
<tr>
<td>console.warn</td>
<td>以警告的方式输出</td>
</tr>
<tr>
<td>console.table</td>
<td>把多维的JSON数据以表格形式输出</td>
</tr>
<tr>
<td>console.time/ console.timeEnd</td>
<td>计算出time/ timeEnd 中间所有程序执行所消耗的时间（受当前电脑性能影响）</td>
</tr>
</tbody></table>
<p><strong>window提示框：在浏览器窗口中弹出一个提示框，提示框中输出指定信息</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>alert</td>
<td>需要等到 alert 弹出框，点击确定或者关闭后，后面的代码才会执行（alert会影响主线程的渲染）；alert弹出的内容都会默认转换为字符串</td>
</tr>
<tr>
<td>confirm</td>
<td>创建一个变量，用来接收用户选择的结果（true|false）</td>
</tr>
<tr>
<td>prompt</td>
<td>在confirm的基础上给用户提供了书写操作<br>点击确定，会将用户的输入信息返回；点击取消，则返回null</td>
</tr>
</tbody></table>
<p><strong>页面插入：向页面指定容器中插入内容</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>document.write</td>
<td>在页面中直接写入，写入的内容会转换为字符串</td>
</tr>
<tr>
<td>innerHTML</td>
<td>能够将标签文本进行识别和渲染；基于此种方法会把之前容器中的内容覆盖掉，想要追加，则使用<code>+=</code>的方法</td>
</tr>
<tr>
<td>innerText</td>
<td>会将所有内容当做普通文本</td>
</tr>
<tr>
<td>value</td>
<td>给页面中的文本框赋值</td>
</tr>
</tbody></table>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%AC%E5%8D%81%E5%85%AD%E8%AE%B2-%E5%9B%BE%E7%BB%93%E6%9E%84%EF%BC%88Java%EF%BC%89/" rel="next" title="数据结构与算法第十六讲-图结构（Java）">
                <i class="fa fa-chevron-left"></i> 数据结构与算法第十六讲-图结构（Java）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/24/JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/" rel="prev" title="JavaScript高级（尚硅谷）">
                JavaScript高级（尚硅谷） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/caticon.jpg"
                alt="Eason" />
            
              <p class="site-author-name" itemprop="name">Eason</p>
              <p class="site-description motion-element" itemprop="description">学习备忘录</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#JS基础"><span class="nav-number">1.</span> <span class="nav-text">JS基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、字面量、变量、标识符"><span class="nav-number">1.1.</span> <span class="nav-text">一、字面量、变量、标识符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、数据类型"><span class="nav-number">1.2.</span> <span class="nav-text">二、数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、运算符"><span class="nav-number">1.3.</span> <span class="nav-text">三、运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、代码块"><span class="nav-number">1.4.</span> <span class="nav-text">四、代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、流程控制语句"><span class="nav-number">1.5.</span> <span class="nav-text">五、流程控制语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#六、对象"><span class="nav-number">1.6.</span> <span class="nav-text">六、对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#七、函数"><span class="nav-number">1.7.</span> <span class="nav-text">七、函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#八、数组（内建对象）"><span class="nav-number">1.8.</span> <span class="nav-text">八、数组（内建对象）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#九、Date对象（内建对象）"><span class="nav-number">1.9.</span> <span class="nav-text">九、Date对象（内建对象）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十、Math对象（内建对象）"><span class="nav-number">1.10.</span> <span class="nav-text">十、Math对象（内建对象）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十一、String对象（内建对象）"><span class="nav-number">1.11.</span> <span class="nav-text">十一、String对象（内建对象）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包装类（仅作了解）"><span class="nav-number">1.12.</span> <span class="nav-text">包装类（仅作了解）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十二、DOM（宿主对象）"><span class="nav-number">1.13.</span> <span class="nav-text">十二、DOM（宿主对象）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十三、BOM（宿主对象）"><span class="nav-number">1.14.</span> <span class="nav-text">十三、BOM（宿主对象）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十四、定时器简介"><span class="nav-number">1.15.</span> <span class="nav-text">十四、定时器简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十五、类的操作"><span class="nav-number">1.16.</span> <span class="nav-text">十五、类的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十六、JSON"><span class="nav-number">1.17.</span> <span class="nav-text">十六、JSON</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十七、三类输出方式"><span class="nav-number">1.18.</span> <span class="nav-text">十七、三类输出方式</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">徐宇颂</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>









<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共78.8k字</span>
</div>






        
<div class="busuanzi-count">

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
